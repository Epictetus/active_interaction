{
  "name": "ActiveInteraction",
  "tagline": "Manage application specific business logic.",
  "body": "# [ActiveInteraction][]\r\n\r\nActiveInteraction manages application-specific business logic.\r\nIt's an implementation of the command pattern in Ruby.\r\n\r\n[![Version](https://badge.fury.io/rb/active_interaction.svg)](https://rubygems.org/gems/active_interaction)\r\n[![Build](https://travis-ci.org/orgsync/active_interaction.svg?branch=master)](https://travis-ci.org/orgsync/active_interaction)\r\n[![Coverage](https://coveralls.io/repos/github/orgsync/active_interaction/badge.svg?branch=master)](https://coveralls.io/r/orgsync/active_interaction)\r\n[![Climate](https://codeclimate.com/github/orgsync/active_interaction/badges/gpa.svg)](https://codeclimate.com/github/orgsync/active_interaction)\r\n[![Dependencies](https://gemnasium.com/orgsync/active_interaction.svg)](https://gemnasium.com/orgsync/active_interaction)\r\n\r\n---\r\n\r\nActiveInteraction gives you a place to put your business logic. It also helps\r\nyou write safer code by validating that your inputs conform to your\r\nexpectations. If ActiveModel deals with your nouns, then ActiveInteraction\r\nhandles your verbs.\r\n\r\nRead more on [the project page][] or check out [the full documentation][].\r\n\r\n- [Installation](#installation)\r\n- [Basic usage](#basic-usage)\r\n  - [Validations](#validations)\r\n- [Filters](#filters)\r\n  - [Array](#array)\r\n  - [Boolean](#boolean)\r\n  - [File](#file)\r\n  - [Hash](#hash)\r\n  - [Interface](#interface)\r\n  - [Object](#object)\r\n  - [String](#string)\r\n  - [Symbol](#symbol)\r\n  - [Dates and times](#dates-and-times)\r\n    - [Date](#date)\r\n    - [DateTime](#datetime)\r\n    - [Time](#time)\r\n  - [Numbers](#numbers)\r\n    - [Decimal](#decimal)\r\n    - [Float](#float)\r\n    - [Integer](#integer)\r\n- [Rails](#rails)\r\n  - [Controller](#controller)\r\n    - [Index](#index)\r\n    - [Show](#show)\r\n    - [New](#new)\r\n    - [Create](#create)\r\n    - [Destroy](#destroy)\r\n    - [Edit](#edit)\r\n    - [Update](#update)\r\n  - [Structure](#structure)\r\n- [Advanced usage](#advanced-usage)\r\n  - [Callbacks](#callbacks)\r\n  - [Composition](#composition)\r\n  - [Defaults](#defaults)\r\n  - [Descriptions](#descriptions)\r\n  - [Errors](#errors)\r\n  - [Forms](#forms)\r\n  - [Grouped inputs](#grouped-inputs)\r\n  - [Optional inputs](#optional-inputs)\r\n  - [Predicates](#predicates)\r\n  - [Translations](#translations)\r\n- [Credits](#credits)\r\n\r\n## Installation\r\n\r\nAdd it to your Gemfile:\r\n\r\n``` rb\r\ngem 'active_interaction', '~> 3.4'\r\n```\r\n\r\nOr install it manually:\r\n\r\n``` sh\r\n$ gem install active_interaction --version '~> 3.4'\r\n```\r\n\r\nThis project uses [Semantic Versioning][]. Check out [the change log][] for a\r\ndetailed list of changes. For help upgrading to version 2, please read [the\r\nannouncement post][].\r\n\r\nActiveInteraction works with Ruby 2.0 through 2.3 and ActiveModel 4.0 through\r\n5.0. If you want to use ActiveInteraction with an older version of Ruby or\r\nActiveModel, use ActiveInteraction < 3.0.0.\r\n\r\n## Basic usage\r\n\r\nTo define an interaction, create a subclass of `ActiveInteraction::Base`. Then\r\nyou need to do two things:\r\n\r\n1.  **Define your inputs.** Use class filter methods to define what you expect\r\n    your inputs to look like. For instance, if you need a boolean flag for\r\n    pepperoni, use `boolean :pepperoni`. Check out [the filters\r\n    section](#filters) for all the available options.\r\n\r\n2.  **Define your business logic.** Do this by implementing the `#execute`\r\n    method. Each input you defined will be available as the type you specified.\r\n    If any of the inputs are invalid, `#execute` won't be run. Filters are\r\n    responsible for type checking your inputs. Check out [the validations\r\n    section](#validations) if you need more than that.\r\n\r\nThat covers the basics. Let's put it all together into a simple example that\r\nsquares a number.\r\n\r\n``` rb\r\nrequire 'active_interaction'\r\n\r\nclass Square < ActiveInteraction::Base\r\n  float :x\r\n\r\n  def execute\r\n    x**2\r\n  end\r\nend\r\n```\r\n\r\nCall `.run` on your interaction to execute it. You must pass a single hash to\r\n`.run`. It will return an instance of your interaction. By convention, we call\r\nthis an outcome. You can use the `#valid?` method to ask the outcome if it's\r\nvalid. If it's invalid, take a look at its errors with `#errors`. In either\r\ncase, the value returned from `#execute` will be stored in `#result`.\r\n\r\n``` rb\r\noutcome = Square.run(x: 'two point one')\r\noutcome.valid?\r\n# => nil\r\noutcome.errors.messages\r\n# => {:x=>[\"is not a valid float\"]}\r\n\r\noutcome = Square.run(x: 2.1)\r\noutcome.valid?\r\n# => true\r\noutcome.result\r\n# => 4.41\r\n```\r\n\r\nYou can also use `.run!` to execute interactions. It's like `.run` but more\r\ndangerous. It doesn't return an outcome. If the outcome would be invalid, it\r\nwill instead raise an error. But if the outcome would be valid, it simply\r\nreturns the result.\r\n\r\n``` rb\r\nSquare.run!(x: 'two point one')\r\n# ActiveInteraction::InvalidInteractionError: X is not a valid float\r\nSquare.run!(x: 2.1)\r\n# => 4.41\r\n```\r\n\r\n### Validations\r\n\r\nActiveInteraction type checks your inputs. Often you'll want more than that.\r\nFor instance, you may want an input to be a string with at least one\r\nnon-whitespace character. Instead of writing your own validation for that, you\r\ncan use validations from ActiveModel.\r\n\r\nThese validations aren't provided by ActiveInteraction. They're from\r\nActiveModel. You can also use any custom validations you wrote yourself in your\r\ninteractions.\r\n\r\n``` rb\r\nclass SayHello < ActiveInteraction::Base\r\n  string :name\r\n\r\n  validates :name,\r\n    presence: true\r\n\r\n  def execute\r\n    \"Hello, #{name}!\"\r\n  end\r\nend\r\n```\r\n\r\nWhen you run this interaction, two things will happen. **First\r\nActiveInteraction will type check your inputs. Then ActiveModel will validate\r\nthem.** If both of those are happy, it will be executed.\r\n\r\n``` rb\r\nSayHello.run!(name: nil)\r\n# ActiveInteraction::InvalidInteractionError: Name is required\r\n\r\nSayHello.run!(name: '')\r\n# ActiveInteraction::InvalidInteractionError: Name can't be blank\r\n\r\nSayHello.run!(name: 'Taylor')\r\n# => \"Hello, Taylor!\"\r\n```\r\n\r\n## Filters\r\n\r\nYou can define filters inside an interaction using the appropriate class\r\nmethod. Each method has the same signature:\r\n\r\n- Some symbolic names. These are the attributes to create.\r\n\r\n- An optional hash of options. Each filter supports at least these two options:\r\n\r\n  - `default` is the fallback value to use if `nil` is given. To make a filter\r\n    optional, set `default: nil`.\r\n\r\n  - `desc` is a human-readable description of the input. This can be useful for\r\n    generating documentation. For more information about this, read [the\r\n    descriptions section](#descriptions).\r\n\r\n- An optional block of sub-filters. Only [array](#array) and [hash](#hash)\r\n  filters support this. Other filters will ignore blocks when given to them.\r\n\r\nLet's take a look at an example filter. It defines three inputs: `x`, `y`, and\r\n`z`. Those inputs are optional and they all share the same description (\"an\r\nexample filter\").\r\n\r\n``` rb\r\narray :x, :y, :z,\r\n  default: nil,\r\n  desc: 'an example filter' do\r\n    # Some filters support sub-filters here.\r\n  end\r\n```\r\n\r\nIn general, filters accept values of the type they correspond to, plus a few\r\nalternatives that can be reasonably coerced. Typically the coercions come from\r\nRails, so `\"1\"` can be interpreted as the boolean value `true`, the string\r\n`\"1\"`, or the number `1`.\r\n\r\n### Array\r\n\r\nIn addition to accepting arrays, array inputs will convert\r\n`ActiveRecord::Relation`s into arrays.\r\n\r\n``` rb\r\nclass ArrayInteraction < ActiveInteraction::Base\r\n  array :toppings\r\n\r\n  def execute\r\n    toppings.size\r\n  end\r\nend\r\n\r\nArrayInteraction.run!(toppings: 'everything')\r\n# ActiveInteraction::InvalidInteractionError: Toppings is not a valid array\r\nArrayInteraction.run!(toppings: [:cheese, 'pepperoni'])\r\n# => 2\r\n```\r\n\r\nUse a block to constrain the types of elements an array can contain.\r\n\r\n``` rb\r\narray :birthdays do\r\n  date\r\nend\r\n```\r\n\r\nNote that you can only have one filter inside an array block, and it must not\r\nhave a name.\r\n\r\n``` rb\r\narray :cows do\r\n  object class: Cow\r\nend\r\n```\r\n\r\n### Boolean\r\n\r\nBoolean filters convert the strings `\"1\"` and `\"true\"` (case-insensitive) into\r\n`true`. They also convert `\"0\"` and `\"false\"` into `false`.\r\n\r\n``` rb\r\nclass BooleanInteraction < ActiveInteraction::Base\r\n  boolean :kool_aid\r\n\r\n  def execute\r\n    'Oh yeah!' if kool_aid\r\n  end\r\nend\r\n\r\nBooleanInteraction.run!(kool_aid: 1)\r\n# ActiveInteraction::InvalidInteractionError: Kool aid is not a valid boolean\r\nBooleanInteraction.run!(kool_aid: true)\r\n# => \"Oh yeah!\"\r\n```\r\n\r\n### File\r\n\r\nFile filters also accept `TempFile`s and anything that responds to `#rewind`.\r\nThat means that you can pass the `params` from uploading files via forms in\r\nRails.\r\n\r\n``` rb\r\nclass FileInteraction < ActiveInteraction::Base\r\n  file :readme\r\n\r\n  def execute\r\n    readme.size\r\n  end\r\nend\r\n\r\nFileInteraction.run!(readme: 'README.md')\r\n# ActiveInteraction::InvalidInteractionError: Readme is not a valid file\r\nFileInteraction.run!(readme: File.open('README.md'))\r\n# => 21563\r\n```\r\n\r\n### Hash\r\n\r\nHash filters accept hashes. The expected value types are given by passing a\r\nblock and nesting other filters. You can have any number of filters inside a\r\nhash, including other hashes.\r\n\r\n``` rb\r\nclass HashInteraction < ActiveInteraction::Base\r\n  hash :preferences do\r\n    boolean :newsletter\r\n    boolean :sweepstakes\r\n  end\r\n\r\n  def execute\r\n    puts 'Thanks for joining the newsletter!' if preferences[:newsletter]\r\n    puts 'Good luck in the sweepstakes!' if preferences[:sweepstakes]\r\n  end\r\nend\r\n\r\nHashInteraction.run!(preferences: 'yes, no')\r\n# ActiveInteraction::InvalidInteractionError: Preferences is not a valid hash\r\nHashInteraction.run!(preferences: { newsletter: true, 'sweepstakes' => false })\r\n# Thanks for joining the newsletter!\r\n# => nil\r\n```\r\n\r\nSetting default hash values can be tricky. The default value has to be either\r\n`nil` or `{}`. Use `nil` to make the hash optional. Use `{}` if you want to set\r\nsome defaults for values inside the hash.\r\n\r\n``` rb\r\nhash :optional,\r\n  default: nil\r\n# => {:optional=>nil}\r\n\r\nhash :with_defaults,\r\n  default: {} do\r\n    boolean :likes_cookies,\r\n      default: true\r\n  end\r\n# => {:with_defaults=>{:likes_cookies=>true}}\r\n```\r\n\r\nBy default, hashes remove any keys that aren't given as nested filters. To\r\nallow all hash keys, set `strip: false`. In general we don't recommend doing\r\nthis, but it's sometimes necessary.\r\n\r\n``` rb\r\nhash :stuff,\r\n  strip: false\r\n```\r\n\r\n### Interface\r\n\r\nInterface filters allow you to specify that an object must respond to a certain\r\nset of methods. This allows you to do duck typing with interactions.\r\n\r\n``` rb\r\nclass InterfaceInteraction < ActiveInteraction::Base\r\n  interface :serializer,\r\n    methods: %i[dump load]\r\n\r\n  def execute\r\n    input = '{ \"is_json\" : true }'\r\n    object = serializer.load(input)\r\n    output = serializer.dump(object)\r\n\r\n    output\r\n  end\r\nend\r\n\r\nrequire 'json'\r\n\r\nInterfaceInteraction.run!(serializer: Object.new)\r\n# ActiveInteraction::InvalidInteractionError: Serializer is not a valid interface\r\nInterfaceInteraction.run!(serializer: JSON)\r\n# => \"{\\\"is_json\\\":true}\"\r\n```\r\n\r\n### Object\r\n\r\nObject filters allow you to require an instance of a particular class. It\r\nchecks either `#is_a?` on the instance or `.===` on the class. Because of that,\r\nit also works with classes that have mixed modules in with `include`.\r\n\r\n``` rb\r\nclass Cow\r\n  def moo\r\n    'Moo!'\r\n  end\r\nend\r\n\r\nclass ObjectInteraction < ActiveInteraction::Base\r\n  object :cow\r\n\r\n  def execute\r\n    cow.moo\r\n  end\r\nend\r\n\r\nObjectInteraction.run!(cow: Object.new)\r\n# ActiveInteraction::InvalidInteractionError: Cow is not a valid object\r\nObjectInteraction.run!(cow: Cow.new)\r\n# => \"Moo!\"\r\n```\r\n\r\nThe class name is automatically determined by the filter name. If your filter\r\nname is different than your class name, use the `class` option. It can be\r\neither the class, a string, or a symbol.\r\n\r\n``` rb\r\nobject :dolly1,\r\n  class: Sheep\r\nobject :dolly2,\r\n  class: 'Sheep'\r\nobject :dolly3,\r\n  class: :Sheep\r\n```\r\n\r\n### String\r\n\r\nString filters define inputs that only accept strings.\r\n\r\n``` rb\r\nclass StringInteraction < ActiveInteraction::Base\r\n  string :name\r\n\r\n  def execute\r\n    \"Hello, #{name}!\"\r\n  end\r\nend\r\n\r\nStringInteraction.run!(name: 0xDEADBEEF)\r\n# ActiveInteraction::InvalidInteractionError: Name is not a valid string\r\nStringInteraction.run!(name: 'Taylor')\r\n# => \"Hello, Taylor!\"\r\n```\r\n\r\nIf you want to strip leading and trailing whitespace from a string, set the\r\n`strip` option to `true`.\r\n\r\n``` rb\r\nstring :comment,\r\n  strip: true\r\n```\r\n\r\n### Symbol\r\n\r\nSymbol filters define inputs that accept symbols. Strings will be converted\r\ninto symbols.\r\n\r\n``` rb\r\nclass SymbolInteraction < ActiveInteraction::Base\r\n  symbol :method\r\n\r\n  def execute\r\n    method.to_proc\r\n  end\r\nend\r\n\r\nSymbolInteraction.run!(method: -> {})\r\n# ActiveInteraction::InvalidInteractionError: Method is not a valid symbol\r\nSymbolInteraction.run!(method: :object_id)\r\n# => #<Proc:0x007fdc9ba94118>\r\n```\r\n\r\n### Dates and times\r\n\r\nFilters that work with dates and times behave similarly. By default, they all\r\nconvert strings into their expected data types using `.parse`. If you give the\r\n`format` option, they will instead convert strings using `.strptime`. Note that\r\nformats won't work with `DateTime` and `Time` filters if a time zone is set.\r\n\r\n#### Date\r\n\r\n``` rb\r\nclass DateInteraction < ActiveInteraction::Base\r\n  date :birthday\r\n\r\n  def execute\r\n    birthday + (18 * 365)\r\n  end\r\nend\r\n\r\nDateInteraction.run!(birthday: 'yesterday')\r\n# ActiveInteraction::InvalidInteractionError: Birthday is not a valid date\r\nDateInteraction.run!(birthday: Date.new(1989, 9, 1))\r\n# => #<Date: 2007-08-28 ((2454341j,0s,0n),+0s,2299161j)>\r\n```\r\n\r\n``` rb\r\ndate :birthday,\r\n  format: '%Y-%m-%d'\r\n```\r\n\r\n#### DateTime\r\n\r\n``` rb\r\nclass DateTimeInteraction < ActiveInteraction::Base\r\n  date_time :now\r\n\r\n  def execute\r\n    now.iso8601\r\n  end\r\nend\r\n\r\nDateTimeInteraction.run!(now: 'now')\r\n# ActiveInteraction::InvalidInteractionError: Now is not a valid date time\r\nDateTimeInteraction.run!(now: DateTime.now)\r\n# => \"2015-03-11T11:04:40-05:00\"\r\n```\r\n\r\n``` rb\r\ndate_time :start,\r\n  format: '%Y-%m-%dT%H:%M:%S'\r\n```\r\n\r\n#### Time\r\n\r\nIn addition to converting strings with `.parse` (or `.strptime`), time filters\r\nconvert numbers with `.at`.\r\n\r\n``` rb\r\nclass TimeInteraction < ActiveInteraction::Base\r\n  time :epoch\r\n\r\n  def execute\r\n    Time.now - epoch\r\n  end\r\nend\r\n\r\nTimeInteraction.run!(epoch: 'a long, long time ago')\r\n# ActiveInteraction::InvalidInteractionError: Epoch is not a valid time\r\nTimeInteraction.run!(epoch: Time.new(1970))\r\n# => 1426068362.5136619\r\n```\r\n\r\n``` rb\r\ntime :start,\r\n  format: '%Y-%m-%dT%H:%M:%S'\r\n```\r\n\r\n### Numbers\r\n\r\nAll numeric filters accept numeric input. They will also convert strings using\r\nthe appropriate method from `Kernel` (like `.Float`).\r\n\r\n#### Decimal\r\n\r\n``` rb\r\nclass DecimalInteraction < ActiveInteraction::Base\r\n  decimal :price\r\n\r\n  def execute\r\n    price * 1.0825\r\n  end\r\nend\r\n\r\nDecimalInteraction.run!(price: 'one ninety-nine')\r\n# ActiveInteraction::InvalidInteractionError: Price is not a valid decimal\r\nDecimalInteraction.run!(price: BigDecimal.new(1.99, 2))\r\n# => #<BigDecimal:7fe792a42028,'0.2165E1',18(45)>\r\n```\r\n\r\nTo specify the number of significant digits, use the `digits` option.\r\n\r\n``` rb\r\ndecimal :dollars,\r\n  digits: 2\r\n```\r\n\r\n#### Float\r\n\r\n``` rb\r\nclass FloatInteraction < ActiveInteraction::Base\r\n  float :x\r\n\r\n  def execute\r\n    x**2\r\n  end\r\nend\r\n\r\nFloatInteraction.run!(x: 'two point one')\r\n# ActiveInteraction::InvalidInteractionError: X is not a valid float\r\nFloatInteraction.run!(x: 2.1)\r\n# => 4.41\r\n```\r\n\r\n#### Integer\r\n\r\n``` rb\r\nclass IntegerInteraction < ActiveInteraction::Base\r\n  integer :limit\r\n\r\n  def execute\r\n    limit.downto(0).to_a\r\n  end\r\nend\r\n\r\nIntegerInteraction.run!(limit: 'ten')\r\n# ActiveInteraction::InvalidInteractionError: Limit is not a valid integer\r\nIntegerInteraction.run!(limit: 10)\r\n# => [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\r\n```\r\n\r\nWhen a `String` is passed into an `integer` input, the value will be coerced.\r\nCoercion is based on `Kernel#Integer` which attempts to detect the base being used.\r\nHowever, you may want to specify the `base` for the conversion to something more\r\nsensible (e.g. `base: 10`).\r\n\r\n``` rb\r\nclass IntegerInteraction < ActiveInteraction::Base\r\n  integer :limit1, base: 10\r\n  integer :limit2\r\n  \r\n  def execute\r\n    [limit1, limit2]\r\n  end\r\nend\r\n\r\nIntegerInteraction.run!(limit1: \"08\", limit2: 8)\r\n# => [8, 8]\r\nIntegerInteraction.run!(limit1: \"08\", limit2: \"08\")\r\n# ArgumentError: invalid value for Integer(): \"08\"\r\n```\r\n\r\n## Rails\r\n\r\nActiveInteraction plays nicely with Rails. You can use interactions to handle\r\nyour business logic instead of models or controllers. To see how it all works,\r\nlet's take a look at a complete example of a controller with the typical\r\nresourceful actions. For a complete working example, check out [Aire][], our\r\nexample Rails application.\r\n\r\n### Controller\r\n\r\n#### Index\r\n\r\n``` rb\r\n# GET /accounts\r\ndef index\r\n  @accounts = ListAccounts.run!\r\nend\r\n```\r\n\r\nSince we're not passing any inputs to `ListAccounts`, it makes sense to use\r\n`.run!` instead of `.run`. If it failed, that would mean we probably messed up\r\nwriting the interaction.\r\n\r\n``` rb\r\nclass ListAccounts < ActiveInteraction::Base\r\n  def execute\r\n    Account.not_deleted.order(last_name: :asc, first_name: :asc)\r\n  end\r\nend\r\n```\r\n\r\n#### Show\r\n\r\nUp next is the show action. For this one we'll define a helper method to handle\r\nraising the correct errors. We have to do this because calling `.run!` would\r\nraise an `ActiveInteraction::InvalidInteractionError` instead of an\r\n`ActiveRecord::RecordNotFound`. That means Rails would render a 500 instead of\r\na 404.\r\n\r\n``` rb\r\n# GET /accounts/:id\r\ndef show\r\n  @account = find_account!\r\nend\r\n\r\nprivate\r\n\r\ndef find_account!\r\n  outcome = FindAccount.run(params)\r\n\r\n  if outcome.valid?\r\n    outcome.result\r\n  else\r\n    fail ActiveRecord::RecordNotFound, outcome.errors.full_messages.to_sentence\r\n  end\r\nend\r\n```\r\n\r\nThis probably looks a little different than you're used to. Rails commonly\r\nhandles this with a `before_filter` that sets the `@account` instance variable.\r\nWhy is all this interaction code better? Two reasons: One, you can reuse the\r\n`FindAccount` interaction in other places, like your API controller or a Resque\r\ntask. And two, if you want to change how accounts are found, you only have to\r\nchange one place.\r\n\r\nInside the interaction, we could use `#find` instead of `#find_by_id`. That way\r\nwe wouldn't need the `#find_account!` helper method in the controller because\r\nthe error would bubble all the way up. However, you should try to avoid raising\r\nerrors from interactions. If you do, you'll have to deal with raised exceptions\r\nas well as the validity of the outcome.\r\n\r\n``` rb\r\nclass FindAccount < ActiveInteraction::Base\r\n  integer :id\r\n\r\n  def execute\r\n    account = Account.not_deleted.find_by_id(id)\r\n\r\n    if account\r\n      account\r\n    else\r\n      errors.add(:id, 'does not exist')\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nNote that it's perfectly fine to add errors during execution. Not all errors\r\nhave to come from type checking or validation.\r\n\r\n#### New\r\n\r\nThe new action will be a little different than the ones we've looked at so far.\r\nInstead of calling `.run` or `.run!`, it's going to initialize a new\r\ninteraction. This is possible because interactions behave like ActiveModels.\r\n\r\n``` rb\r\n# GET /accounts/new\r\ndef new\r\n  @account = CreateAccount.new\r\nend\r\n```\r\n\r\nSince interactions behave like ActiveModels, we can use ActiveModel validations\r\nwith them. We'll use validations here to make sure that the first and last\r\nnames are not blank. [The validations section](#validations) goes into more\r\ndetail about this.\r\n\r\n``` rb\r\nclass CreateAccount < ActiveInteraction::Base\r\n  string :first_name, :last_name\r\n\r\n  validates :first_name, :last_name,\r\n    presence: true\r\n\r\n  def to_model\r\n    Account.new\r\n  end\r\n\r\n  def execute\r\n    account = Account.new(inputs)\r\n\r\n    unless account.save\r\n      errors.merge!(account.errors)\r\n    end\r\n\r\n    account\r\n  end\r\nend\r\n```\r\n\r\nWe used a couple of advanced features here. The `#to_model` method helps\r\ndetermine the correct form to use in the view. Check out [the section on\r\nforms](#forms) for more about that. Inside `#execute`, we merge errors. This is\r\na convenient way to move errors from one object to another. Read more about it\r\nin [the errors section](#errors).\r\n\r\n#### Create\r\n\r\nThe create action has a lot in common with the new action. Both of them use the\r\n`CreateAccount` interaction. And if creating the account fails, this action\r\nfalls back to rendering the new action.\r\n\r\n``` rb\r\n# POST /accounts\r\ndef create\r\n  outcome = CreateAccount.run(params.fetch(:account, {}))\r\n\r\n  if outcome.valid?\r\n    redirect_to(outcome.result)\r\n  else\r\n    @account = outcome\r\n    render(:new)\r\n  end\r\nend\r\n```\r\n\r\nNote that we have to pass a hash to `.run`. Passing `nil` is an error.\r\n\r\nSince we're using an interaction, we don't need strong parameters. The\r\ninteraction will ignore any inputs that weren't defined by filters. So you can\r\nforget about `params.require` and `params.permit` because interactions handle\r\nthat for you.\r\n\r\n#### Destroy\r\n\r\nThe destroy action will reuse the `#find_account!` helper method we wrote\r\nearlier.\r\n\r\n``` rb\r\n# DELETE /accounts/:id\r\ndef destroy\r\n  DestroyAccount.run!(account: find_account!)\r\n  redirect_to(accounts_url)\r\nend\r\n```\r\n\r\nIn this simple example, the destroy interaction doesn't do much. It's not clear\r\nthat you gain anything by putting it in an interaction. But in the future, when\r\nyou need to do more than `account.destroy`, you'll only have to update one\r\nspot.\r\n\r\n``` rb\r\nclass DestroyAccount < ActiveInteraction::Base\r\n  object :account\r\n\r\n  def execute\r\n    account.destroy\r\n  end\r\nend\r\n```\r\n\r\n#### Edit\r\n\r\nJust like the destroy action, editing uses the `#find_account!` helper. Then it\r\ncreates a new interaction instance to use as a form object.\r\n\r\n``` rb\r\n# GET /accounts/:id/edit\r\ndef edit\r\n  account = find_account!\r\n  @account = UpdateAccount.new(\r\n    account: account,\r\n    first_name: account.first_name,\r\n    last_name: account.last_name)\r\nend\r\n```\r\n\r\nThe interaction that updates accounts is more complicated than the others. It\r\nrequires an account to update, but the other inputs are optional. If they're\r\nmissing, it'll ignore those attributes. If they're present, it'll update them.\r\n\r\nActiveInteraction generates predicate methods (like `#first_name?`) for your\r\ninputs. They will return `false` if the input is `nil` and `true` otherwise.\r\nSkip to [the predicates section](#predicates) for more information about them.\r\n\r\n``` rb\r\nclass UpdateAccount < ActiveInteraction::Base\r\n  object :account\r\n\r\n  string :first_name, :last_name,\r\n    default: nil\r\n\r\n  validates :first_name,\r\n    presence: true,\r\n    if: :first_name?\r\n  validates :last_name,\r\n    presence: true,\r\n    if: :last_name?\r\n\r\n  def execute\r\n    account.first_name = first_name if first_name?\r\n    account.last_name = last_name if last_name?\r\n\r\n    unless account.save\r\n      errors.merge!(account.errors)\r\n    end\r\n\r\n    account\r\n  end\r\nend\r\n```\r\n\r\n#### Update\r\n\r\nHopefully you've gotten the hang of this by now. We'll use `#find_account!` to\r\nget the account. Then we'll build up the inputs for `UpdateAccount`. Then we'll\r\nrun the interaction and either redirect to the updated account or back to the\r\nedit page.\r\n\r\n``` rb\r\n# PUT /accounts/:id\r\ndef update\r\n  inputs = { account: find_account! }.reverse_merge(params[:account])\r\n  outcome = UpdateAccount.run(inputs)\r\n\r\n  if outcome.valid?\r\n    redirect_to(outcome.result)\r\n  else\r\n    @account = outcome\r\n    render(:edit)\r\n  end\r\nend\r\n```\r\n\r\n### Structure\r\n\r\nWe recommend putting your interactions in `app/interactions`. It's also very\r\nhelpful to group them by model. That way you can look in\r\n`app/interactions/accounts` for all the ways you can interact with accounts. In\r\norder to use this structure add\r\n`config.autoload_paths += Dir.glob(\"#{config.root}/app/interactions/*\")` in\r\nyour `application.rb`\r\n\r\n```\r\n- app/\r\n  - controllers/\r\n    - accounts_controller.rb\r\n  - interactions/\r\n    - accounts/\r\n      - create_account.rb\r\n      - destroy_account.rb\r\n      - find_account.rb\r\n      - list_accounts.rb\r\n      - update_account.rb\r\n  - models/\r\n    - account.rb\r\n  - views/\r\n    - account/\r\n      - edit.html.erb\r\n      - index.html.erb\r\n      - new.html.erb\r\n      - show.html.erb\r\n```\r\n\r\n## Advanced usage\r\n\r\n### Callbacks\r\n\r\nActiveModel provides a powerful framework for defining callbacks.\r\nActiveInteraction hooks into that framework to allow hooking into various parts\r\nof an interaction's lifecycle.\r\n\r\n``` rb\r\nclass Increment < ActiveInteraction::Base\r\n  set_callback :type_check, :before, -> { puts 'before type check' }\r\n\r\n  integer :x\r\n\r\n  set_callback :validate, :after, -> { puts 'after validate' }\r\n\r\n  validates :x,\r\n    numericality: { greater_than_or_equal_to: 0 }\r\n\r\n  set_callback :execute, :around, lambda { |_interaction, block|\r\n    puts '>>>'\r\n    block.call\r\n    puts '<<<'\r\n  }\r\n\r\n  def execute\r\n    puts 'executing'\r\n    x + 1\r\n  end\r\nend\r\n\r\nIncrement.run!(x: 1)\r\n# before type check\r\n# after validate\r\n# >>>\r\n# executing\r\n# <<<\r\n# => 2\r\n```\r\n\r\nIn order, the available callbacks are `type_check`, `validate`, and `execute`.\r\nYou can set `before`, `after`, or `around` on any of them.\r\n\r\n### Composition\r\n\r\nYou can run interactions from within other interactions with `#compose`. If the\r\ninteraction is successful, it'll return the result (just like if you had called\r\nit with `.run!`). If something went wrong, execution will halt immediately and\r\nthe errors will be moved onto the caller.\r\n\r\n``` rb\r\nclass Add < ActiveInteraction::Base\r\n  integer :x, :y\r\n\r\n  def execute\r\n    x + y\r\n  end\r\nend\r\n\r\nclass AddThree < ActiveInteraction::Base\r\n  integer :x\r\n\r\n  def execute\r\n    compose(Add, x: x, y: 3)\r\n  end\r\nend\r\n\r\nAddThree.run!(x: 5)\r\n# => 8\r\n```\r\n\r\nTo bring in filters from another interaction, use `.import_filters`. Combined\r\nwith `inputs`, delegating to another interaction is a piece of cake.\r\n\r\n``` rb\r\nclass AddAndDouble < ActiveInteraction::Base\r\n  import_filters Add\r\n\r\n  def execute\r\n    compose(Add, inputs) * 2\r\n  end\r\nend\r\n```\r\n\r\nNote that errors in composed interactions have a few tricky cases. See [the\r\nerrors section][] for more information about them.\r\n\r\n### Defaults\r\n\r\nThe default value for an input can take on many different forms. Setting the\r\ndefault to `nil` makes the input optional. Setting it to some value makes that\r\nthe default value for that input. Setting it to a lambda will lazily set the\r\ndefault value for that input. That means the value will be computed when the\r\ninteraction is run, as opposed to when it is defined.\r\n\r\nLambda defaults are evaluated in the context of the interaction, so you can use\r\nthe values of other inputs in them.\r\n\r\n``` rb\r\n# This input is optional.\r\ntime :a, default: nil\r\n# This input defaults to `Time.at(123)`.\r\ntime :b, default: Time.at(123)\r\n# This input lazily defaults to `Time.now`.\r\ntime :c, default: -> { Time.now }\r\n# This input defaults to the value of `c` plus 10 seconds.\r\ntime :d, default: -> { c + 10 }\r\n```\r\n\r\n### Descriptions\r\n\r\nUse the `desc` option to provide human-readable descriptions of filters. You\r\nshould prefer these to comments because they can be used to generate\r\ndocumentation. The interaction class has a `.filters` method that returns a\r\nhash of filters. Each filter has a `#desc` method that returns the description.\r\n\r\n``` rb\r\nclass Descriptive < ActiveInteraction::Base\r\n  string :first_name,\r\n    desc: 'your first name'\r\n  string :last_name,\r\n    desc: 'your last name'\r\nend\r\n\r\nDescriptive.filters.each do |name, filter|\r\n  puts \"#{name}: #{filter.desc}\"\r\nend\r\n# first_name: your first name\r\n# last_name: your last name\r\n```\r\n\r\n### Errors\r\n\r\nActiveInteraction provides detailed errors for easier introspection and testing\r\nof errors. Detailed errors improve on regular errors by adding a symbol that\r\nrepresents the type of error that has occurred. Let's look at an example where\r\nan item is purchased using a credit card.\r\n\r\n``` rb\r\nclass BuyItem < ActiveInteraction::Base\r\n  object :credit_card, :item\r\n  hash :options do\r\n    boolean :gift_wrapped\r\n  end\r\n\r\n  def execute\r\n    order = credit_card.purchase(item)\r\n    notify(credit_card.account)\r\n    order\r\n  end\r\n\r\n  private def notify(account)\r\n    # ...\r\n  end\r\nend\r\n```\r\n\r\nHaving missing or invalid inputs causes the interaction to fail and return\r\nerrors.\r\n\r\n``` rb\r\noutcome = BuyItem.run(item: 'Thing', options: { gift_wrapped: 'yes' })\r\noutcome.errors.messages\r\n# => {:credit_card=>[\"is required\"], :item=>[\"is not a valid object\"], :options=>[\"has an invalid nested value (\\\"gift_wrapped\\\" => \\\"yes\\\")\"]}\r\n```\r\n\r\nDetermining the type of error based on the string is difficult if not\r\nimpossible. Calling `#details` instead of `#messages` on `errors` gives you\r\nthe same list of errors with a testable label representing the error.\r\n\r\n``` rb\r\noutcome.errors.details\r\n# => {:credit_card=>[{:error=>:missing}], :item=>[{:type=>\"object\", :error=>:invalid_type}], :options=>[{:name=>\"\\\"gift_wrapped\\\"\", :value=>\"\\\"yes\\\"\", :error=>:invalid_nested}]}\r\n```\r\n\r\nDetailed errors can also be manually added during the execute call by passing a\r\nsymbol to `#add` instead of a string.\r\n\r\n``` rb\r\ndef execute\r\n  errors.add(:monster, :no_passage)\r\nend\r\n```\r\n\r\nThese types of errors will become standard with Rails 5. ActiveInteraction's\r\nimplementation is based off of [active_model-errors_details][].\r\n\r\nActiveInteraction also supports merging errors. This is useful if you want to\r\ndelegate validation to some other object. For example, if you have an\r\ninteraction that updates a record, you might want that record to validate\r\nitself. By using the `#merge!` helper on `errors`, you can do exactly that.\r\n\r\n``` rb\r\nclass UpdateThing < ActiveInteraction::Base\r\n  object :thing\r\n\r\n  def execute\r\n    unless thing.save\r\n      errors.merge!(thing.errors)\r\n    end\r\n\r\n    thing\r\n  end\r\nend\r\n```\r\n\r\nWhen a composed interaction fails, its errors are merged onto the caller. This\r\ngenerally produces good error messages, but there are a few cases to look out\r\nfor.\r\n\r\n``` rb\r\nclass Inner < ActiveInteraction::Base\r\n  boolean :x, :y\r\nend\r\n\r\nclass Outer < ActiveInteraction::Base\r\n  string :x\r\n  boolean :z, default: nil\r\n\r\n  def execute\r\n    compose(Inner, x: x, y: z)\r\n  end\r\nend\r\n\r\noutcome = Outer.run(x: 'yes')\r\noutcome.errors.details\r\n# => { :x    => [{ :error => :invalid_type, :type => \"boolean\" }],\r\n#      :base => [{ :error => \"Y is required\" }] }\r\noutcome.errors.full_messages.join(' and ')\r\n# => \"X is not a valid boolean and Y is required\"\r\n```\r\n\r\nSince both interactions have an input called `x`, the inner error for that\r\ninput is moved to the `x` error on the outer interaction. This results in a\r\nmisleading error that claims the input `x` is not a valid boolean even though\r\nit's a string on the outer interaction.\r\n\r\nSince only the inner interaction has an input called `y`, the inner error for\r\nthat input is moved to the `base` error on the outer interaction. This results\r\nin a confusing error that claims the input `y` is required even though it's not\r\npresent on the outer interaction.\r\n\r\n### Forms\r\n\r\nThe outcome returned by `.run` can be used in forms as though it were an\r\nActiveModel object. You can also create a form object by calling `.new` on the\r\ninteraction.\r\n\r\nGiven an application with an `Account` model we'll create a new `Account` using\r\nthe `CreateAccount` interaction.\r\n\r\n```rb\r\n# GET /accounts/new\r\ndef new\r\n  @account = CreateAccount.new\r\nend\r\n\r\n# POST /accounts\r\ndef create\r\n  outcome = CreateAccount.run(params.fetch(:account, {}))\r\n\r\n  if outcome.valid?\r\n    redirect_to(outcome.result)\r\n  else\r\n    @account = outcome\r\n    render(:new)\r\n  end\r\nend\r\n```\r\n\r\nThe form used to create a new `Account` has slightly more information on the\r\n`form_for` call than you might expect.\r\n\r\n```erb\r\n<%= form_for @account, as: :account, url: accounts_path do |f| %>\r\n  <%= f.text_field :first_name %>\r\n  <%= f.text_field :last_name %>\r\n  <%= f.submit 'Create' %>\r\n<% end %>\r\n```\r\n\r\nThis is necessary because we want the form to act like it is creating a new\r\n`Account`. Defining `to_model` on the `CreateAccount` interaction tells the\r\nform to treat our interaction like an `Account`.\r\n\r\n```rb\r\nclass CreateAccount < ActiveInteraction::Base\r\n  # ...\r\n\r\n  def to_model\r\n    Account.new\r\n  end\r\nend\r\n```\r\n\r\nNow our `form_for` call knows how to generate the correct URL and param name\r\n(i.e. `params[:account]`).\r\n\r\n```erb\r\n# app/views/accounts/new.html.erb\r\n<%= form_for @account do |f| %>\r\n  <%# ... %>\r\n<% end %>\r\n```\r\n\r\nIf you have an interaction that updates an `Account`, you can define `to_model`\r\nto return the object you're updating.\r\n\r\n```rb\r\nclass UpdateAccount < ActiveInteraction::Base\r\n  # ...\r\n\r\n  object :account\r\n\r\n  def to_model\r\n    account\r\n  end\r\nend\r\n```\r\n\r\nActiveInteraction also supports [formtastic][] and [simple_form][]. The filters\r\nused to define the inputs on your interaction will relay type information to\r\nthese gems. As a result, form fields will automatically use the appropriate\r\ninput type.\r\n\r\n### Grouped inputs\r\n\r\nIt can be convenient to apply the same options to a bunch of inputs. One common\r\nuse case is making many inputs optional. Instead of setting `default: nil` on\r\neach one of them, you can use [`with_options`][] to reduce duplication.\r\n\r\n``` rb\r\nwith_options default: nil do\r\n  date :birthday\r\n  string :name\r\n  boolean :wants_cake\r\nend\r\n```\r\n\r\n### Optional inputs\r\n\r\nOptional inputs can be defined by using the `:default` option as described in\r\n[the filters section][]. Within the interaction, provided and default values\r\nare merged to create `inputs`. There are times where it is useful to know\r\nwhether a value was passed to `run` or the result of a filter default. In\r\nparticular, it is useful when `nil` is an acceptable value. For example, you\r\nmay optionally track your users' birthdays. You can use the `given?` predicate\r\nto see if an input was even passed to `run`.\r\n\r\n``` rb\r\nclass UpdateUser < ActiveInteraction::Base\r\n  object :user\r\n  date :birthday,\r\n    default: nil\r\n\r\n  def execute\r\n    user.birthday = birthday if given?(:birthday)\r\n    errors.merge!(user.errors) unless user.save\r\n    user\r\n  end\r\nend\r\n```\r\n\r\nNow you have a few options. If you don't want to update their birthday, leave\r\nit out of the hash. If you want to remove their birthday, set `birthday: nil`.\r\nAnd if you want to update it, pass in the new value as usual.\r\n\r\n``` rb\r\nuser = User.find(...)\r\n\r\n# Don't update their birthday.\r\nUpdateUser.run!(user: user)\r\n\r\n# Remove their birthday.\r\nUpdateUser.run!(user: user, birthday: nil)\r\n\r\n# Update their birthday.\r\nUpdateUser.run!(user: user, birthday: Date.new(2000, 1, 2))\r\n```\r\n\r\n### Predicates\r\n\r\nActiveInteraction creates a predicate method for every input defined by a\r\nfilter. So if you have an input called `foo`, there will be a predicate method\r\ncalled `#foo?`. That method will tell you if the input was given (that is, if\r\nit was not `nil`).\r\n\r\n``` rb\r\nclass SayHello < ActiveInteraction::Base\r\n  string :name,\r\n    default: nil\r\n\r\n  def execute\r\n    if name?\r\n      \"Hello, #{name}!\"\r\n    else\r\n      \"Howdy, stranger!\"\r\n    end\r\n  end\r\nend\r\n\r\nSayHello.run!(name: nil)\r\n# => \"Howdy, stranger!\"\r\nSayHello.run!(name: 'Taylor')\r\n# => \"Hello, Taylor!\"\r\n```\r\n\r\nThis can be confusing for boolean inputs. If you have some boolean input `foo`,\r\nthen the actual value of that input is available through `foo`. The associated\r\npredicate method, `#foo?`, will tell you if that value is not `nil`. So it will\r\nonly be `false` if the input is optional and happens to be `nil`.\r\n\r\nSee [the optional inputs section][] for help on determining if an input was\r\npresent in the input hash instead of just `nil`.\r\n\r\n### Translations\r\n\r\nActiveInteraction is i18n aware out of the box! All you have to do is add\r\ntranslations to your project. In Rails, these typically go into\r\n`config/locales`. For example, let's say that for some reason you want to print\r\neverything out backwards. Simply add translations for ActiveInteraction to your\r\n`hsilgne` locale.\r\n\r\n``` yml\r\n# config/locales/hsilgne.yml\r\nhsilgne:\r\n  active_interaction:\r\n    types:\r\n      array: yarra\r\n      boolean: naeloob\r\n      date: etad\r\n      date_time: emit etad\r\n      decimal: lamiced\r\n      file: elif\r\n      float: taolf\r\n      hash: hsah\r\n      integer: regetni\r\n      interface: ecafretni\r\n      object: tcejbo\r\n      string: gnirts\r\n      symbol: lobmys\r\n      time: emit\r\n    errors:\r\n      messages:\r\n        invalid: dilavni si\r\n        invalid_nested: (%{value} <= %{name}) eulav detsen dilavni na sah\r\n        invalid_type: '%{type} dilav a ton si'\r\n        missing: deriuqer si\r\n```\r\n\r\nThen set your locale and run interactions like normal.\r\n\r\n``` rb\r\nclass I18nInteraction < ActiveInteraction::Base\r\n  string :name\r\nend\r\n\r\nI18nInteraction.run(name: false).errors.messages[:name]\r\n# => [\"is not a valid string\"]\r\n\r\nI18n.locale = :hsilgne\r\nI18nInteraction.run(name: false).errors.messages[:name]\r\n# => [\"gnirts dilav a ton si\"]\r\n```\r\n\r\n## Credits\r\n\r\nActiveInteraction is brought to you by [Aaron Lasseigne][] and\r\n[Taylor Fausak][] from [OrgSync][]. We were inspired by the fantastic work done\r\nby [Jonathan Novak][] on [Mutations][].\r\n\r\nIf you want to contribute to ActiveInteraction, please read\r\n[our contribution guidelines][]. A [complete list of contributors][] is\r\navailable on GitHub.\r\n\r\nActiveInteraction is licensed under [the MIT License][].\r\n\r\n[activeinteraction]: https://github.com/orgsync/active_interaction\r\n[the project page]: http://orgsync.github.io/active_interaction/\r\n[the full documentation]: http://rubydoc.info/github/orgsync/active_interaction\r\n[semantic versioning]: http://semver.org/spec/v2.0.0.html\r\n[the change log]: CHANGELOG.md\r\n[the announcement post]: http://devblog.orgsync.com/2015/05/06/announcing-active-interaction-2/\r\n[active_model-errors_details]: https://github.com/cowbell/active_model-errors_details\r\n[aaron lasseigne]: https://github.com/AaronLasseigne\r\n[taylor fausak]: https://github.com/tfausak\r\n[orgsync]: https://github.com/orgsync\r\n[jonathan novak]: https://github.com/cypriss\r\n[mutations]: https://github.com/cypriss/mutations\r\n[our contribution guidelines]: CONTRIBUTING.md\r\n[complete list of contributors]: https://github.com/orgsync/active_interaction/graphs/contributors\r\n[the mit license]: LICENSE.md\r\n[formtastic]: https://rubygems.org/gems/formtastic\r\n[simple_form]: https://rubygems.org/gems/simple_form\r\n[the filters section]: #filters\r\n[the errors section]: #errors\r\n[the optional inputs section]: #optional-inputs\r\n[aire]: example\r\n[`with_options`]: http://api.rubyonrails.org/classes/Object.html#method-i-with_options\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}