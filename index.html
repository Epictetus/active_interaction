<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>ActiveInteraction by orgsync</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">ActiveInteraction</h1>
      <h2 class="project-tagline">Manage application specific business logic.</h2>
      <a href="https://github.com/orgsync/active_interaction" class="btn">View on GitHub</a>
      <a href="https://github.com/orgsync/active_interaction/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/orgsync/active_interaction/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="activeinteraction" class="anchor" href="#activeinteraction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a href="https://github.com/orgsync/active_interaction">ActiveInteraction</a>
</h1>

<p>ActiveInteraction manages application-specific business logic.
It's an implementation of the command pattern in Ruby.</p>

<p><a href="https://rubygems.org/gems/active_interaction"><img src="https://badge.fury.io/rb/active_interaction.svg" alt="Version"></a>
<a href="https://travis-ci.org/orgsync/active_interaction"><img src="https://travis-ci.org/orgsync/active_interaction.svg?branch=master" alt="Build"></a>
<a href="https://coveralls.io/r/orgsync/active_interaction"><img src="https://coveralls.io/repos/github/orgsync/active_interaction/badge.svg?branch=master" alt="Coverage"></a>
<a href="https://codeclimate.com/github/orgsync/active_interaction"><img src="https://codeclimate.com/github/orgsync/active_interaction/badges/gpa.svg" alt="Climate"></a>
<a href="https://gemnasium.com/orgsync/active_interaction"><img src="https://gemnasium.com/orgsync/active_interaction.svg" alt="Dependencies"></a></p>

<hr>

<p>ActiveInteraction gives you a place to put your business logic. It also helps
you write safer code by validating that your inputs conform to your
expectations. If ActiveModel deals with your nouns, then ActiveInteraction
handles your verbs.</p>

<p>Read more on <a href="http://orgsync.github.io/active_interaction/">the project page</a> or check out <a href="http://rubydoc.info/github/orgsync/active_interaction">the full documentation</a>.</p>

<ul>
<li><a href="#installation">Installation</a></li>
<li>
<a href="#basic-usage">Basic usage</a>

<ul>
<li><a href="#validations">Validations</a></li>
</ul>
</li>
<li>
<a href="#filters">Filters</a>

<ul>
<li><a href="#array">Array</a></li>
<li><a href="#boolean">Boolean</a></li>
<li><a href="#file">File</a></li>
<li><a href="#hash">Hash</a></li>
<li><a href="#interface">Interface</a></li>
<li><a href="#object">Object</a></li>
<li><a href="#string">String</a></li>
<li><a href="#symbol">Symbol</a></li>
<li>
<a href="#dates-and-times">Dates and times</a>

<ul>
<li><a href="#date">Date</a></li>
<li><a href="#datetime">DateTime</a></li>
<li><a href="#time">Time</a></li>
</ul>
</li>
<li>
<a href="#numbers">Numbers</a>

<ul>
<li><a href="#decimal">Decimal</a></li>
<li><a href="#float">Float</a></li>
<li><a href="#integer">Integer</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#rails">Rails</a>

<ul>
<li>
<a href="#controller">Controller</a>

<ul>
<li><a href="#index">Index</a></li>
<li><a href="#show">Show</a></li>
<li><a href="#new">New</a></li>
<li><a href="#create">Create</a></li>
<li><a href="#destroy">Destroy</a></li>
<li><a href="#edit">Edit</a></li>
<li><a href="#update">Update</a></li>
</ul>
</li>
<li><a href="#structure">Structure</a></li>
</ul>
</li>
<li>
<a href="#advanced-usage">Advanced usage</a>

<ul>
<li><a href="#callbacks">Callbacks</a></li>
<li><a href="#composition">Composition</a></li>
<li><a href="#defaults">Defaults</a></li>
<li><a href="#descriptions">Descriptions</a></li>
<li><a href="#errors">Errors</a></li>
<li><a href="#forms">Forms</a></li>
<li><a href="#grouped-inputs">Grouped inputs</a></li>
<li><a href="#optional-inputs">Optional inputs</a></li>
<li><a href="#predicates">Predicates</a></li>
<li><a href="#translations">Translations</a></li>
</ul>
</li>
<li><a href="#credits">Credits</a></li>
</ul>

<h2>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Installation</h2>

<p>Add it to your Gemfile:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">gem</span> <span class="pl-s"><span class="pl-pds">'</span>active_interaction<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>~&gt; 3.4<span class="pl-pds">'</span></span></pre></div>

<p>Or install it manually:</p>

<div class="highlight highlight-source-shell"><pre>$ gem install active_interaction --version <span class="pl-s"><span class="pl-pds">'</span>~&gt; 3.4<span class="pl-pds">'</span></span></pre></div>

<p>This project uses <a href="http://semver.org/spec/v2.0.0.html">Semantic Versioning</a>. Check out <a href="CHANGELOG.md">the change log</a> for a
detailed list of changes. For help upgrading to version 2, please read <a href="http://devblog.orgsync.com/2015/05/06/announcing-active-interaction-2/">the
announcement post</a>.</p>

<p>ActiveInteraction works with Ruby 2.0 through 2.3 and ActiveModel 4.0 through
5.0. If you want to use ActiveInteraction with an older version of Ruby or
ActiveModel, use ActiveInteraction &lt; 3.0.0.</p>

<h2>
<a id="basic-usage" class="anchor" href="#basic-usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Basic usage</h2>

<p>To define an interaction, create a subclass of <code>ActiveInteraction::Base</code>. Then
you need to do two things:</p>

<ol>
<li><p><strong>Define your inputs.</strong> Use class filter methods to define what you expect
your inputs to look like. For instance, if you need a boolean flag for
pepperoni, use <code>boolean :pepperoni</code>. Check out <a href="#filters">the filters
section</a> for all the available options.</p></li>
<li><p><strong>Define your business logic.</strong> Do this by implementing the <code>#execute</code>
method. Each input you defined will be available as the type you specified.
If any of the inputs are invalid, <code>#execute</code> won't be run. Filters are
responsible for type checking your inputs. Check out <a href="#validations">the validations
section</a> if you need more than that.</p></li>
</ol>

<p>That covers the basics. Let's put it all together into a simple example that
squares a number.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>active_interaction<span class="pl-pds">'</span></span>

<span class="pl-k">class</span> <span class="pl-en">Square<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  float <span class="pl-c1">:x</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    x<span class="pl-k">**</span><span class="pl-c1">2</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>Call <code>.run</code> on your interaction to execute it. You must pass a single hash to
<code>.run</code>. It will return an instance of your interaction. By convention, we call
this an outcome. You can use the <code>#valid?</code> method to ask the outcome if it's
valid. If it's invalid, take a look at its errors with <code>#errors</code>. In either
case, the value returned from <code>#execute</code> will be stored in <code>#result</code>.</p>

<div class="highlight highlight-source-ruby"><pre>outcome <span class="pl-k">=</span> <span class="pl-c1">Square</span>.run(<span class="pl-c1">x:</span> <span class="pl-s"><span class="pl-pds">'</span>two point one<span class="pl-pds">'</span></span>)
outcome.valid?
<span class="pl-c"># =&gt; nil</span>
outcome.errors.messages
<span class="pl-c"># =&gt; {:x=&gt;["is not a valid float"]}</span>

outcome <span class="pl-k">=</span> <span class="pl-c1">Square</span>.run(<span class="pl-c1">x:</span> <span class="pl-c1">2.1</span>)
outcome.valid?
<span class="pl-c"># =&gt; true</span>
outcome.result
<span class="pl-c"># =&gt; 4.41</span></pre></div>

<p>You can also use <code>.run!</code> to execute interactions. It's like <code>.run</code> but more
dangerous. It doesn't return an outcome. If the outcome would be invalid, it
will instead raise an error. But if the outcome would be valid, it simply
returns the result.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">Square</span>.run!(<span class="pl-c1">x:</span> <span class="pl-s"><span class="pl-pds">'</span>two point one<span class="pl-pds">'</span></span>)
<span class="pl-c"># ActiveInteraction::InvalidInteractionError: X is not a valid float</span>
<span class="pl-c1">Square</span>.run!(<span class="pl-c1">x:</span> <span class="pl-c1">2.1</span>)
<span class="pl-c"># =&gt; 4.41</span></pre></div>

<h3>
<a id="validations" class="anchor" href="#validations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Validations</h3>

<p>ActiveInteraction type checks your inputs. Often you'll want more than that.
For instance, you may want an input to be a string with at least one
non-whitespace character. Instead of writing your own validation for that, you
can use validations from ActiveModel.</p>

<p>These validations aren't provided by ActiveInteraction. They're from
ActiveModel. You can also use any custom validations you wrote yourself in your
interactions.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">SayHello<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  string <span class="pl-c1">:name</span>

  validates <span class="pl-c1">:name</span>,
    <span class="pl-c1">presence:</span> <span class="pl-c1">true</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    <span class="pl-s"><span class="pl-pds">"</span>Hello, <span class="pl-pse">#{</span><span class="pl-s1">name</span><span class="pl-pse"><span class="pl-s1">}</span></span>!<span class="pl-pds">"</span></span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>When you run this interaction, two things will happen. <strong>First
ActiveInteraction will type check your inputs. Then ActiveModel will validate
them.</strong> If both of those are happy, it will be executed.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">SayHello</span>.run!(<span class="pl-c1">name:</span> <span class="pl-c1">nil</span>)
<span class="pl-c"># ActiveInteraction::InvalidInteractionError: Name is required</span>

<span class="pl-c1">SayHello</span>.run!(<span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>)
<span class="pl-c"># ActiveInteraction::InvalidInteractionError: Name can't be blank</span>

<span class="pl-c1">SayHello</span>.run!(<span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span>Taylor<span class="pl-pds">'</span></span>)
<span class="pl-c"># =&gt; "Hello, Taylor!"</span></pre></div>

<h2>
<a id="filters" class="anchor" href="#filters" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Filters</h2>

<p>You can define filters inside an interaction using the appropriate class
method. Each method has the same signature:</p>

<ul>
<li><p>Some symbolic names. These are the attributes to create.</p></li>
<li>
<p>An optional hash of options. Each filter supports at least these two options:</p>

<ul>
<li><p><code>default</code> is the fallback value to use if <code>nil</code> is given. To make a filter
optional, set <code>default: nil</code>.</p></li>
<li><p><code>desc</code> is a human-readable description of the input. This can be useful for
generating documentation. For more information about this, read <a href="#descriptions">the
descriptions section</a>.</p></li>
</ul>
</li>
<li><p>An optional block of sub-filters. Only <a href="#array">array</a> and <a href="#hash">hash</a>
filters support this. Other filters will ignore blocks when given to them.</p></li>
</ul>

<p>Let's take a look at an example filter. It defines three inputs: <code>x</code>, <code>y</code>, and
<code>z</code>. Those inputs are optional and they all share the same description ("an
example filter").</p>

<div class="highlight highlight-source-ruby"><pre>array <span class="pl-c1">:x</span>, <span class="pl-c1">:y</span>, <span class="pl-c1">:z</span>,
  <span class="pl-c1">default:</span> <span class="pl-c1">nil</span>,
  <span class="pl-c1">desc:</span> <span class="pl-s"><span class="pl-pds">'</span>an example filter<span class="pl-pds">'</span></span> <span class="pl-k">do</span>
    <span class="pl-c"># Some filters support sub-filters here.</span>
  <span class="pl-k">end</span></pre></div>

<p>In general, filters accept values of the type they correspond to, plus a few
alternatives that can be reasonably coerced. Typically the coercions come from
Rails, so <code>"1"</code> can be interpreted as the boolean value <code>true</code>, the string
<code>"1"</code>, or the number <code>1</code>.</p>

<h3>
<a id="array" class="anchor" href="#array" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Array</h3>

<p>In addition to accepting arrays, array inputs will convert
<code>ActiveRecord::Relation</code>s into arrays.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">ArrayInteraction<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  array <span class="pl-c1">:toppings</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    toppings.size
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">ArrayInteraction</span>.run!(<span class="pl-c1">toppings:</span> <span class="pl-s"><span class="pl-pds">'</span>everything<span class="pl-pds">'</span></span>)
<span class="pl-c"># ActiveInteraction::InvalidInteractionError: Toppings is not a valid array</span>
<span class="pl-c1">ArrayInteraction</span>.run!(<span class="pl-c1">toppings:</span> [<span class="pl-c1">:cheese</span>, <span class="pl-s"><span class="pl-pds">'</span>pepperoni<span class="pl-pds">'</span></span>])
<span class="pl-c"># =&gt; 2</span></pre></div>

<p>Use a block to constrain the types of elements an array can contain.</p>

<div class="highlight highlight-source-ruby"><pre>array <span class="pl-c1">:birthdays</span> <span class="pl-k">do</span>
  date
<span class="pl-k">end</span></pre></div>

<p>Note that you can only have one filter inside an array block, and it must not
have a name.</p>

<div class="highlight highlight-source-ruby"><pre>array <span class="pl-c1">:cows</span> <span class="pl-k">do</span>
  object <span class="pl-c1">class:</span> <span class="pl-c1">Cow</span>
<span class="pl-k">end</span></pre></div>

<h3>
<a id="boolean" class="anchor" href="#boolean" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Boolean</h3>

<p>Boolean filters convert the strings <code>"1"</code> and <code>"true"</code> (case-insensitive) into
<code>true</code>. They also convert <code>"0"</code> and <code>"false"</code> into <code>false</code>.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">BooleanInteraction<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  boolean <span class="pl-c1">:kool_aid</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    <span class="pl-s"><span class="pl-pds">'</span>Oh yeah!<span class="pl-pds">'</span></span> <span class="pl-k">if</span> kool_aid
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">BooleanInteraction</span>.run!(<span class="pl-c1">kool_aid:</span> <span class="pl-c1">1</span>)
<span class="pl-c"># ActiveInteraction::InvalidInteractionError: Kool aid is not a valid boolean</span>
<span class="pl-c1">BooleanInteraction</span>.run!(<span class="pl-c1">kool_aid:</span> <span class="pl-c1">true</span>)
<span class="pl-c"># =&gt; "Oh yeah!"</span></pre></div>

<h3>
<a id="file" class="anchor" href="#file" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>File</h3>

<p>File filters also accept <code>TempFile</code>s and anything that responds to <code>#rewind</code>.
That means that you can pass the <code>params</code> from uploading files via forms in
Rails.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">FileInteraction<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  file <span class="pl-c1">:readme</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    readme.size
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">FileInteraction</span>.run!(<span class="pl-c1">readme:</span> <span class="pl-s"><span class="pl-pds">'</span>README.md<span class="pl-pds">'</span></span>)
<span class="pl-c"># ActiveInteraction::InvalidInteractionError: Readme is not a valid file</span>
<span class="pl-c1">FileInteraction</span>.run!(<span class="pl-c1">readme:</span> <span class="pl-c1">File</span>.open(<span class="pl-s"><span class="pl-pds">'</span>README.md<span class="pl-pds">'</span></span>))
<span class="pl-c"># =&gt; 21563</span></pre></div>

<h3>
<a id="hash" class="anchor" href="#hash" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Hash</h3>

<p>Hash filters accept hashes. The expected value types are given by passing a
block and nesting other filters. You can have any number of filters inside a
hash, including other hashes.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">HashInteraction<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  hash <span class="pl-c1">:preferences</span> <span class="pl-k">do</span>
    boolean <span class="pl-c1">:newsletter</span>
    boolean <span class="pl-c1">:sweepstakes</span>
  <span class="pl-k">end</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    puts <span class="pl-s"><span class="pl-pds">'</span>Thanks for joining the newsletter!<span class="pl-pds">'</span></span> <span class="pl-k">if</span> preferences[<span class="pl-c1">:newsletter</span>]
    puts <span class="pl-s"><span class="pl-pds">'</span>Good luck in the sweepstakes!<span class="pl-pds">'</span></span> <span class="pl-k">if</span> preferences[<span class="pl-c1">:sweepstakes</span>]
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">HashInteraction</span>.run!(<span class="pl-c1">preferences:</span> <span class="pl-s"><span class="pl-pds">'</span>yes, no<span class="pl-pds">'</span></span>)
<span class="pl-c"># ActiveInteraction::InvalidInteractionError: Preferences is not a valid hash</span>
<span class="pl-c1">HashInteraction</span>.run!(<span class="pl-c1">preferences:</span> { <span class="pl-c1">newsletter:</span> <span class="pl-c1">true</span>, <span class="pl-s"><span class="pl-pds">'</span>sweepstakes<span class="pl-pds">'</span></span> =&gt; <span class="pl-c1">false</span> })
<span class="pl-c"># Thanks for joining the newsletter!</span>
<span class="pl-c"># =&gt; nil</span></pre></div>

<p>Setting default hash values can be tricky. The default value has to be either
<code>nil</code> or <code>{}</code>. Use <code>nil</code> to make the hash optional. Use <code>{}</code> if you want to set
some defaults for values inside the hash.</p>

<div class="highlight highlight-source-ruby"><pre>hash <span class="pl-c1">:optional</span>,
  <span class="pl-c1">default:</span> <span class="pl-c1">nil</span>
<span class="pl-c"># =&gt; {:optional=&gt;nil}</span>

hash <span class="pl-c1">:with_defaults</span>,
  <span class="pl-c1">default:</span> {} <span class="pl-k">do</span>
    boolean <span class="pl-c1">:likes_cookies</span>,
      <span class="pl-c1">default:</span> <span class="pl-c1">true</span>
  <span class="pl-k">end</span>
<span class="pl-c"># =&gt; {:with_defaults=&gt;{:likes_cookies=&gt;true}}</span></pre></div>

<p>By default, hashes remove any keys that aren't given as nested filters. To
allow all hash keys, set <code>strip: false</code>. In general we don't recommend doing
this, but it's sometimes necessary.</p>

<div class="highlight highlight-source-ruby"><pre>hash <span class="pl-c1">:stuff</span>,
  <span class="pl-c1">strip:</span> <span class="pl-c1">false</span></pre></div>

<h3>
<a id="interface" class="anchor" href="#interface" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Interface</h3>

<p>Interface filters allow you to specify that an object must respond to a certain
set of methods. This allows you to do duck typing with interactions.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">InterfaceInteraction<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  interface <span class="pl-c1">:serializer</span>,
    <span class="pl-c1">methods:</span> <span class="pl-k">%</span>i[dump load]

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    input <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>{ "is_json" : true }<span class="pl-pds">'</span></span>
    object <span class="pl-k">=</span> serializer.load(input)
    output <span class="pl-k">=</span> serializer.dump(object)

    output
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>json<span class="pl-pds">'</span></span>

<span class="pl-c1">InterfaceInteraction</span>.run!(<span class="pl-c1">serializer:</span> <span class="pl-c1">Object</span>.<span class="pl-k">new</span>)
<span class="pl-c"># ActiveInteraction::InvalidInteractionError: Serializer is not a valid interface</span>
<span class="pl-c1">InterfaceInteraction</span>.run!(<span class="pl-c1">serializer:</span> <span class="pl-c1">JSON</span>)
<span class="pl-c"># =&gt; "{\"is_json\":true}"</span></pre></div>

<h3>
<a id="object" class="anchor" href="#object" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Object</h3>

<p>Object filters allow you to require an instance of a particular class. It
checks either <code>#is_a?</code> on the instance or <code>.===</code> on the class. Because of that,
it also works with classes that have mixed modules in with <code>include</code>.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">Cow</span>
  <span class="pl-k">def</span> <span class="pl-en">moo</span>
    <span class="pl-s"><span class="pl-pds">'</span>Moo!<span class="pl-pds">'</span></span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">class</span> <span class="pl-en">ObjectInteraction<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  object <span class="pl-c1">:cow</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    cow.moo
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">ObjectInteraction</span>.run!(<span class="pl-c1">cow:</span> <span class="pl-c1">Object</span>.<span class="pl-k">new</span>)
<span class="pl-c"># ActiveInteraction::InvalidInteractionError: Cow is not a valid object</span>
<span class="pl-c1">ObjectInteraction</span>.run!(<span class="pl-c1">cow:</span> <span class="pl-c1">Cow</span>.<span class="pl-k">new</span>)
<span class="pl-c"># =&gt; "Moo!"</span></pre></div>

<p>The class name is automatically determined by the filter name. If your filter
name is different than your class name, use the <code>class</code> option. It can be
either the class, a string, or a symbol.</p>

<div class="highlight highlight-source-ruby"><pre>object <span class="pl-c1">:dolly1</span>,
  <span class="pl-c1">class:</span> <span class="pl-c1">Sheep</span>
object <span class="pl-c1">:dolly2</span>,
  <span class="pl-c1">class:</span> <span class="pl-s"><span class="pl-pds">'</span>Sheep<span class="pl-pds">'</span></span>
object <span class="pl-c1">:dolly3</span>,
  <span class="pl-c1">class:</span> <span class="pl-c1">:Sheep</span></pre></div>

<h3>
<a id="string" class="anchor" href="#string" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>String</h3>

<p>String filters define inputs that only accept strings.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">StringInteraction<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  string <span class="pl-c1">:name</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    <span class="pl-s"><span class="pl-pds">"</span>Hello, <span class="pl-pse">#{</span><span class="pl-s1">name</span><span class="pl-pse"><span class="pl-s1">}</span></span>!<span class="pl-pds">"</span></span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">StringInteraction</span>.run!(<span class="pl-c1">name:</span> 0xDEADBEEF)
<span class="pl-c"># ActiveInteraction::InvalidInteractionError: Name is not a valid string</span>
<span class="pl-c1">StringInteraction</span>.run!(<span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span>Taylor<span class="pl-pds">'</span></span>)
<span class="pl-c"># =&gt; "Hello, Taylor!"</span></pre></div>

<p>If you want to strip leading and trailing whitespace from a string, set the
<code>strip</code> option to <code>true</code>.</p>

<div class="highlight highlight-source-ruby"><pre>string <span class="pl-c1">:comment</span>,
  <span class="pl-c1">strip:</span> <span class="pl-c1">true</span></pre></div>

<h3>
<a id="symbol" class="anchor" href="#symbol" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Symbol</h3>

<p>Symbol filters define inputs that accept symbols. Strings will be converted
into symbols.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">SymbolInteraction<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  symbol <span class="pl-c1">:method</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    method.to_proc
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">SymbolInteraction</span>.run!(<span class="pl-c1">method:</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> {})
<span class="pl-c"># ActiveInteraction::InvalidInteractionError: Method is not a valid symbol</span>
<span class="pl-c1">SymbolInteraction</span>.run!(<span class="pl-c1">method:</span> <span class="pl-c1">:object_id</span>)
<span class="pl-c"># =&gt; #&lt;Proc:0x007fdc9ba94118&gt;</span></pre></div>

<h3>
<a id="dates-and-times" class="anchor" href="#dates-and-times" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Dates and times</h3>

<p>Filters that work with dates and times behave similarly. By default, they all
convert strings into their expected data types using <code>.parse</code>. If you give the
<code>format</code> option, they will instead convert strings using <code>.strptime</code>. Note that
formats won't work with <code>DateTime</code> and <code>Time</code> filters if a time zone is set.</p>

<h4>
<a id="date" class="anchor" href="#date" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Date</h4>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">DateInteraction<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  date <span class="pl-c1">:birthday</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    birthday <span class="pl-k">+</span> (<span class="pl-c1">18</span> <span class="pl-k">*</span> <span class="pl-c1">365</span>)
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">DateInteraction</span>.run!(<span class="pl-c1">birthday:</span> <span class="pl-s"><span class="pl-pds">'</span>yesterday<span class="pl-pds">'</span></span>)
<span class="pl-c"># ActiveInteraction::InvalidInteractionError: Birthday is not a valid date</span>
<span class="pl-c1">DateInteraction</span>.run!(<span class="pl-c1">birthday:</span> <span class="pl-c1">Date</span>.<span class="pl-k">new</span>(<span class="pl-c1">1989</span>, <span class="pl-c1">9</span>, <span class="pl-c1">1</span>))
<span class="pl-c"># =&gt; #&lt;Date: 2007-08-28 ((2454341j,0s,0n),+0s,2299161j)&gt;</span></pre></div>

<div class="highlight highlight-source-ruby"><pre>date <span class="pl-c1">:birthday</span>,
  <span class="pl-c1">format:</span> <span class="pl-s"><span class="pl-pds">'</span>%Y-%m-%d<span class="pl-pds">'</span></span></pre></div>

<h4>
<a id="datetime" class="anchor" href="#datetime" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DateTime</h4>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">DateTimeInteraction<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  date_time <span class="pl-c1">:now</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    now.iso8601
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">DateTimeInteraction</span>.run!(<span class="pl-c1">now:</span> <span class="pl-s"><span class="pl-pds">'</span>now<span class="pl-pds">'</span></span>)
<span class="pl-c"># ActiveInteraction::InvalidInteractionError: Now is not a valid date time</span>
<span class="pl-c1">DateTimeInteraction</span>.run!(<span class="pl-c1">now:</span> <span class="pl-c1">DateTime</span>.now)
<span class="pl-c"># =&gt; "2015-03-11T11:04:40-05:00"</span></pre></div>

<div class="highlight highlight-source-ruby"><pre>date_time <span class="pl-c1">:start</span>,
  <span class="pl-c1">format:</span> <span class="pl-s"><span class="pl-pds">'</span>%Y-%m-%dT%H:%M:%S<span class="pl-pds">'</span></span></pre></div>

<h4>
<a id="time" class="anchor" href="#time" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Time</h4>

<p>In addition to converting strings with <code>.parse</code> (or <code>.strptime</code>), time filters
convert numbers with <code>.at</code>.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">TimeInteraction<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  time <span class="pl-c1">:epoch</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    <span class="pl-c1">Time</span>.now <span class="pl-k">-</span> epoch
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">TimeInteraction</span>.run!(<span class="pl-c1">epoch:</span> <span class="pl-s"><span class="pl-pds">'</span>a long, long time ago<span class="pl-pds">'</span></span>)
<span class="pl-c"># ActiveInteraction::InvalidInteractionError: Epoch is not a valid time</span>
<span class="pl-c1">TimeInteraction</span>.run!(<span class="pl-c1">epoch:</span> <span class="pl-c1">Time</span>.<span class="pl-k">new</span>(<span class="pl-c1">1970</span>))
<span class="pl-c"># =&gt; 1426068362.5136619</span></pre></div>

<div class="highlight highlight-source-ruby"><pre>time <span class="pl-c1">:start</span>,
  <span class="pl-c1">format:</span> <span class="pl-s"><span class="pl-pds">'</span>%Y-%m-%dT%H:%M:%S<span class="pl-pds">'</span></span></pre></div>

<h3>
<a id="numbers" class="anchor" href="#numbers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Numbers</h3>

<p>All numeric filters accept numeric input. They will also convert strings using
the appropriate method from <code>Kernel</code> (like <code>.Float</code>).</p>

<h4>
<a id="decimal" class="anchor" href="#decimal" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Decimal</h4>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">DecimalInteraction<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  decimal <span class="pl-c1">:price</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    price <span class="pl-k">*</span> <span class="pl-c1">1.0825</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">DecimalInteraction</span>.run!(<span class="pl-c1">price:</span> <span class="pl-s"><span class="pl-pds">'</span>one ninety-nine<span class="pl-pds">'</span></span>)
<span class="pl-c"># ActiveInteraction::InvalidInteractionError: Price is not a valid decimal</span>
<span class="pl-c1">DecimalInteraction</span>.run!(<span class="pl-c1">price:</span> <span class="pl-c1">BigDecimal</span>.<span class="pl-k">new</span>(<span class="pl-c1">1.99</span>, <span class="pl-c1">2</span>))
<span class="pl-c"># =&gt; #&lt;BigDecimal:7fe792a42028,'0.2165E1',18(45)&gt;</span></pre></div>

<p>To specify the number of significant digits, use the <code>digits</code> option.</p>

<div class="highlight highlight-source-ruby"><pre>decimal <span class="pl-c1">:dollars</span>,
  <span class="pl-c1">digits:</span> <span class="pl-c1">2</span></pre></div>

<h4>
<a id="float" class="anchor" href="#float" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Float</h4>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">FloatInteraction<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  float <span class="pl-c1">:x</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    x<span class="pl-k">**</span><span class="pl-c1">2</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">FloatInteraction</span>.run!(<span class="pl-c1">x:</span> <span class="pl-s"><span class="pl-pds">'</span>two point one<span class="pl-pds">'</span></span>)
<span class="pl-c"># ActiveInteraction::InvalidInteractionError: X is not a valid float</span>
<span class="pl-c1">FloatInteraction</span>.run!(<span class="pl-c1">x:</span> <span class="pl-c1">2.1</span>)
<span class="pl-c"># =&gt; 4.41</span></pre></div>

<h4>
<a id="integer" class="anchor" href="#integer" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Integer</h4>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">IntegerInteraction<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  integer <span class="pl-c1">:limit</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    limit.downto(<span class="pl-c1">0</span>).to_a
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">IntegerInteraction</span>.run!(<span class="pl-c1">limit:</span> <span class="pl-s"><span class="pl-pds">'</span>ten<span class="pl-pds">'</span></span>)
<span class="pl-c"># ActiveInteraction::InvalidInteractionError: Limit is not a valid integer</span>
<span class="pl-c1">IntegerInteraction</span>.run!(<span class="pl-c1">limit:</span> <span class="pl-c1">10</span>)
<span class="pl-c"># =&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span></pre></div>

<p>When a <code>String</code> is passed into an <code>integer</code> input, the value will be coerced.
Coercion is based on <code>Kernel#Integer</code> which attempts to detect the base being used.
However, you may want to specify the <code>base</code> for the conversion to something more
sensible (e.g. <code>base: 10</code>).</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">IntegerInteraction<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  integer <span class="pl-c1">:limit1</span>, <span class="pl-c1">base:</span> <span class="pl-c1">10</span>
  integer <span class="pl-c1">:limit2</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    [limit1, limit2]
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">IntegerInteraction</span>.run!(<span class="pl-c1">limit1:</span> <span class="pl-s"><span class="pl-pds">"</span>08<span class="pl-pds">"</span></span>, <span class="pl-c1">limit2:</span> <span class="pl-c1">8</span>)
<span class="pl-c"># =&gt; [8, 8]</span>
<span class="pl-c1">IntegerInteraction</span>.run!(<span class="pl-c1">limit1:</span> <span class="pl-s"><span class="pl-pds">"</span>08<span class="pl-pds">"</span></span>, <span class="pl-c1">limit2:</span> <span class="pl-s"><span class="pl-pds">"</span>08<span class="pl-pds">"</span></span>)
<span class="pl-c"># ArgumentError: invalid value for Integer(): "08"</span></pre></div>

<h2>
<a id="rails" class="anchor" href="#rails" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Rails</h2>

<p>ActiveInteraction plays nicely with Rails. You can use interactions to handle
your business logic instead of models or controllers. To see how it all works,
let's take a look at a complete example of a controller with the typical
resourceful actions. For a complete working example, check out <a href="example">Aire</a>, our
example Rails application.</p>

<h3>
<a id="controller" class="anchor" href="#controller" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Controller</h3>

<h4>
<a id="index" class="anchor" href="#index" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Index</h4>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c"># GET /accounts</span>
<span class="pl-k">def</span> <span class="pl-en">index</span>
  <span class="pl-smi">@accounts</span> <span class="pl-k">=</span> <span class="pl-c1">ListAccounts</span>.run!
<span class="pl-k">end</span></pre></div>

<p>Since we're not passing any inputs to <code>ListAccounts</code>, it makes sense to use
<code>.run!</code> instead of <code>.run</code>. If it failed, that would mean we probably messed up
writing the interaction.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">ListAccounts<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    <span class="pl-c1">Account</span>.not_deleted.order(<span class="pl-c1">last_name:</span> <span class="pl-c1">:asc</span>, <span class="pl-c1">first_name:</span> <span class="pl-c1">:asc</span>)
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<h4>
<a id="show" class="anchor" href="#show" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Show</h4>

<p>Up next is the show action. For this one we'll define a helper method to handle
raising the correct errors. We have to do this because calling <code>.run!</code> would
raise an <code>ActiveInteraction::InvalidInteractionError</code> instead of an
<code>ActiveRecord::RecordNotFound</code>. That means Rails would render a 500 instead of
a 404.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c"># GET /accounts/:id</span>
<span class="pl-k">def</span> <span class="pl-en">show</span>
  <span class="pl-smi">@account</span> <span class="pl-k">=</span> find_account!
<span class="pl-k">end</span>

<span class="pl-k">private</span>

<span class="pl-k">def</span> <span class="pl-en">find_account!</span>
  outcome <span class="pl-k">=</span> <span class="pl-c1">FindAccount</span>.run(params)

  <span class="pl-k">if</span> outcome.valid?
    outcome.result
  <span class="pl-k">else</span>
    fail <span class="pl-c1">ActiveRecord</span>::<span class="pl-c1">RecordNotFound</span>, outcome.errors.full_messages.to_sentence
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>This probably looks a little different than you're used to. Rails commonly
handles this with a <code>before_filter</code> that sets the <code>@account</code> instance variable.
Why is all this interaction code better? Two reasons: One, you can reuse the
<code>FindAccount</code> interaction in other places, like your API controller or a Resque
task. And two, if you want to change how accounts are found, you only have to
change one place.</p>

<p>Inside the interaction, we could use <code>#find</code> instead of <code>#find_by_id</code>. That way
we wouldn't need the <code>#find_account!</code> helper method in the controller because
the error would bubble all the way up. However, you should try to avoid raising
errors from interactions. If you do, you'll have to deal with raised exceptions
as well as the validity of the outcome.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">FindAccount<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  integer <span class="pl-c1">:id</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    account <span class="pl-k">=</span> <span class="pl-c1">Account</span>.not_deleted.find_by_id(id)

    <span class="pl-k">if</span> account
      account
    <span class="pl-k">else</span>
      errors.add(<span class="pl-c1">:id</span>, <span class="pl-s"><span class="pl-pds">'</span>does not exist<span class="pl-pds">'</span></span>)
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>Note that it's perfectly fine to add errors during execution. Not all errors
have to come from type checking or validation.</p>

<h4>
<a id="new" class="anchor" href="#new" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>New</h4>

<p>The new action will be a little different than the ones we've looked at so far.
Instead of calling <code>.run</code> or <code>.run!</code>, it's going to initialize a new
interaction. This is possible because interactions behave like ActiveModels.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c"># GET /accounts/new</span>
<span class="pl-k">def</span> <span class="pl-en">new</span>
  <span class="pl-smi">@account</span> <span class="pl-k">=</span> <span class="pl-c1">CreateAccount</span>.<span class="pl-k">new</span>
<span class="pl-k">end</span></pre></div>

<p>Since interactions behave like ActiveModels, we can use ActiveModel validations
with them. We'll use validations here to make sure that the first and last
names are not blank. <a href="#validations">The validations section</a> goes into more
detail about this.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">CreateAccount<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  string <span class="pl-c1">:first_name</span>, <span class="pl-c1">:last_name</span>

  validates <span class="pl-c1">:first_name</span>, <span class="pl-c1">:last_name</span>,
    <span class="pl-c1">presence:</span> <span class="pl-c1">true</span>

  <span class="pl-k">def</span> <span class="pl-en">to_model</span>
    <span class="pl-c1">Account</span>.<span class="pl-k">new</span>
  <span class="pl-k">end</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    account <span class="pl-k">=</span> <span class="pl-c1">Account</span>.<span class="pl-k">new</span>(inputs)

    <span class="pl-k">unless</span> account.save
      errors.merge!(account.errors)
    <span class="pl-k">end</span>

    account
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>We used a couple of advanced features here. The <code>#to_model</code> method helps
determine the correct form to use in the view. Check out <a href="#forms">the section on
forms</a> for more about that. Inside <code>#execute</code>, we merge errors. This is
a convenient way to move errors from one object to another. Read more about it
in <a href="#errors">the errors section</a>.</p>

<h4>
<a id="create" class="anchor" href="#create" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Create</h4>

<p>The create action has a lot in common with the new action. Both of them use the
<code>CreateAccount</code> interaction. And if creating the account fails, this action
falls back to rendering the new action.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c"># POST /accounts</span>
<span class="pl-k">def</span> <span class="pl-en">create</span>
  outcome <span class="pl-k">=</span> <span class="pl-c1">CreateAccount</span>.run(params.fetch(<span class="pl-c1">:account</span>, {}))

  <span class="pl-k">if</span> outcome.valid?
    redirect_to(outcome.result)
  <span class="pl-k">else</span>
    <span class="pl-smi">@account</span> <span class="pl-k">=</span> outcome
    render(<span class="pl-c1">:new</span>)
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>Note that we have to pass a hash to <code>.run</code>. Passing <code>nil</code> is an error.</p>

<p>Since we're using an interaction, we don't need strong parameters. The
interaction will ignore any inputs that weren't defined by filters. So you can
forget about <code>params.require</code> and <code>params.permit</code> because interactions handle
that for you.</p>

<h4>
<a id="destroy" class="anchor" href="#destroy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Destroy</h4>

<p>The destroy action will reuse the <code>#find_account!</code> helper method we wrote
earlier.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c"># DELETE /accounts/:id</span>
<span class="pl-k">def</span> <span class="pl-en">destroy</span>
  <span class="pl-c1">DestroyAccount</span>.run!(<span class="pl-c1">account:</span> find_account!)
  redirect_to(accounts_url)
<span class="pl-k">end</span></pre></div>

<p>In this simple example, the destroy interaction doesn't do much. It's not clear
that you gain anything by putting it in an interaction. But in the future, when
you need to do more than <code>account.destroy</code>, you'll only have to update one
spot.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">DestroyAccount<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  object <span class="pl-c1">:account</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    account.destroy
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<h4>
<a id="edit" class="anchor" href="#edit" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Edit</h4>

<p>Just like the destroy action, editing uses the <code>#find_account!</code> helper. Then it
creates a new interaction instance to use as a form object.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c"># GET /accounts/:id/edit</span>
<span class="pl-k">def</span> <span class="pl-en">edit</span>
  account <span class="pl-k">=</span> find_account!
  <span class="pl-smi">@account</span> <span class="pl-k">=</span> <span class="pl-c1">UpdateAccount</span>.<span class="pl-k">new</span>(
    <span class="pl-c1">account:</span> account,
    <span class="pl-c1">first_name:</span> account.first_name,
    <span class="pl-c1">last_name:</span> account.last_name)
<span class="pl-k">end</span></pre></div>

<p>The interaction that updates accounts is more complicated than the others. It
requires an account to update, but the other inputs are optional. If they're
missing, it'll ignore those attributes. If they're present, it'll update them.</p>

<p>ActiveInteraction generates predicate methods (like <code>#first_name?</code>) for your
inputs. They will return <code>false</code> if the input is <code>nil</code> and <code>true</code> otherwise.
Skip to <a href="#predicates">the predicates section</a> for more information about them.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">UpdateAccount<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  object <span class="pl-c1">:account</span>

  string <span class="pl-c1">:first_name</span>, <span class="pl-c1">:last_name</span>,
    <span class="pl-c1">default:</span> <span class="pl-c1">nil</span>

  validates <span class="pl-c1">:first_name</span>,
    <span class="pl-c1">presence:</span> <span class="pl-c1">true</span>,
    <span class="pl-c1">if:</span> <span class="pl-c1">:first_name?</span>
  validates <span class="pl-c1">:last_name</span>,
    <span class="pl-c1">presence:</span> <span class="pl-c1">true</span>,
    <span class="pl-c1">if:</span> <span class="pl-c1">:last_name?</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    account.first_name <span class="pl-k">=</span> first_name <span class="pl-k">if</span> first_name?
    account.last_name <span class="pl-k">=</span> last_name <span class="pl-k">if</span> last_name?

    <span class="pl-k">unless</span> account.save
      errors.merge!(account.errors)
    <span class="pl-k">end</span>

    account
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<h4>
<a id="update" class="anchor" href="#update" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Update</h4>

<p>Hopefully you've gotten the hang of this by now. We'll use <code>#find_account!</code> to
get the account. Then we'll build up the inputs for <code>UpdateAccount</code>. Then we'll
run the interaction and either redirect to the updated account or back to the
edit page.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c"># PUT /accounts/:id</span>
<span class="pl-k">def</span> <span class="pl-en">update</span>
  inputs <span class="pl-k">=</span> { <span class="pl-c1">account:</span> find_account! }.reverse_merge(params[<span class="pl-c1">:account</span>])
  outcome <span class="pl-k">=</span> <span class="pl-c1">UpdateAccount</span>.run(inputs)

  <span class="pl-k">if</span> outcome.valid?
    redirect_to(outcome.result)
  <span class="pl-k">else</span>
    <span class="pl-smi">@account</span> <span class="pl-k">=</span> outcome
    render(<span class="pl-c1">:edit</span>)
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<h3>
<a id="structure" class="anchor" href="#structure" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Structure</h3>

<p>We recommend putting your interactions in <code>app/interactions</code>. It's also very
helpful to group them by model. That way you can look in
<code>app/interactions/accounts</code> for all the ways you can interact with accounts. In
order to use this structure add
<code>config.autoload_paths += Dir.glob("#{config.root}/app/interactions/*")</code> in
your <code>application.rb</code></p>

<pre><code>- app/
  - controllers/
    - accounts_controller.rb
  - interactions/
    - accounts/
      - create_account.rb
      - destroy_account.rb
      - find_account.rb
      - list_accounts.rb
      - update_account.rb
  - models/
    - account.rb
  - views/
    - account/
      - edit.html.erb
      - index.html.erb
      - new.html.erb
      - show.html.erb
</code></pre>

<h2>
<a id="advanced-usage" class="anchor" href="#advanced-usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Advanced usage</h2>

<h3>
<a id="callbacks" class="anchor" href="#callbacks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Callbacks</h3>

<p>ActiveModel provides a powerful framework for defining callbacks.
ActiveInteraction hooks into that framework to allow hooking into various parts
of an interaction's lifecycle.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">Increment<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  set_callback <span class="pl-c1">:type_check</span>, <span class="pl-c1">:before</span>, <span class="pl-k">-</span><span class="pl-k">&gt;</span> { puts <span class="pl-s"><span class="pl-pds">'</span>before type check<span class="pl-pds">'</span></span> }

  integer <span class="pl-c1">:x</span>

  set_callback <span class="pl-c1">:validate</span>, <span class="pl-c1">:after</span>, <span class="pl-k">-</span><span class="pl-k">&gt;</span> { puts <span class="pl-s"><span class="pl-pds">'</span>after validate<span class="pl-pds">'</span></span> }

  validates <span class="pl-c1">:x</span>,
    <span class="pl-c1">numericality:</span> { <span class="pl-c1">greater_than_or_equal_to:</span> <span class="pl-c1">0</span> }

  set_callback <span class="pl-c1">:execute</span>, <span class="pl-c1">:around</span>, lambda { |<span class="pl-smi">_interaction</span>, <span class="pl-smi">block</span>|
    puts <span class="pl-s"><span class="pl-pds">'</span>&gt;&gt;&gt;<span class="pl-pds">'</span></span>
    block.call
    puts <span class="pl-s"><span class="pl-pds">'</span>&lt;&lt;&lt;<span class="pl-pds">'</span></span>
  }

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    puts <span class="pl-s"><span class="pl-pds">'</span>executing<span class="pl-pds">'</span></span>
    x <span class="pl-k">+</span> <span class="pl-c1">1</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">Increment</span>.run!(<span class="pl-c1">x:</span> <span class="pl-c1">1</span>)
<span class="pl-c"># before type check</span>
<span class="pl-c"># after validate</span>
<span class="pl-c"># &gt;&gt;&gt;</span>
<span class="pl-c"># executing</span>
<span class="pl-c"># &lt;&lt;&lt;</span>
<span class="pl-c"># =&gt; 2</span></pre></div>

<p>In order, the available callbacks are <code>type_check</code>, <code>validate</code>, and <code>execute</code>.
You can set <code>before</code>, <code>after</code>, or <code>around</code> on any of them.</p>

<h3>
<a id="composition" class="anchor" href="#composition" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Composition</h3>

<p>You can run interactions from within other interactions with <code>#compose</code>. If the
interaction is successful, it'll return the result (just like if you had called
it with <code>.run!</code>). If something went wrong, execution will halt immediately and
the errors will be moved onto the caller.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">Add<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  integer <span class="pl-c1">:x</span>, <span class="pl-c1">:y</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    x <span class="pl-k">+</span> y
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">class</span> <span class="pl-en">AddThree<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  integer <span class="pl-c1">:x</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    compose(<span class="pl-c1">Add</span>, <span class="pl-c1">x:</span> x, <span class="pl-c1">y:</span> <span class="pl-c1">3</span>)
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">AddThree</span>.run!(<span class="pl-c1">x:</span> <span class="pl-c1">5</span>)
<span class="pl-c"># =&gt; 8</span></pre></div>

<p>To bring in filters from another interaction, use <code>.import_filters</code>. Combined
with <code>inputs</code>, delegating to another interaction is a piece of cake.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">AddAndDouble<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  import_filters <span class="pl-c1">Add</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    compose(<span class="pl-c1">Add</span>, inputs) <span class="pl-k">*</span> <span class="pl-c1">2</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>Note that errors in composed interactions have a few tricky cases. See <a href="#errors">the
errors section</a> for more information about them.</p>

<h3>
<a id="defaults" class="anchor" href="#defaults" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Defaults</h3>

<p>The default value for an input can take on many different forms. Setting the
default to <code>nil</code> makes the input optional. Setting it to some value makes that
the default value for that input. Setting it to a lambda will lazily set the
default value for that input. That means the value will be computed when the
interaction is run, as opposed to when it is defined.</p>

<p>Lambda defaults are evaluated in the context of the interaction, so you can use
the values of other inputs in them.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c"># This input is optional.</span>
time <span class="pl-c1">:a</span>, <span class="pl-c1">default:</span> <span class="pl-c1">nil</span>
<span class="pl-c"># This input defaults to `Time.at(123)`.</span>
time <span class="pl-c1">:b</span>, <span class="pl-c1">default:</span> <span class="pl-c1">Time</span>.at(<span class="pl-c1">123</span>)
<span class="pl-c"># This input lazily defaults to `Time.now`.</span>
time <span class="pl-c1">:c</span>, <span class="pl-c1">default:</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> { <span class="pl-c1">Time</span>.now }
<span class="pl-c"># This input defaults to the value of `c` plus 10 seconds.</span>
time <span class="pl-c1">:d</span>, <span class="pl-c1">default:</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> { c <span class="pl-k">+</span> <span class="pl-c1">10</span> }</pre></div>

<h3>
<a id="descriptions" class="anchor" href="#descriptions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Descriptions</h3>

<p>Use the <code>desc</code> option to provide human-readable descriptions of filters. You
should prefer these to comments because they can be used to generate
documentation. The interaction class has a <code>.filters</code> method that returns a
hash of filters. Each filter has a <code>#desc</code> method that returns the description.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">Descriptive<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  string <span class="pl-c1">:first_name</span>,
    <span class="pl-c1">desc:</span> <span class="pl-s"><span class="pl-pds">'</span>your first name<span class="pl-pds">'</span></span>
  string <span class="pl-c1">:last_name</span>,
    <span class="pl-c1">desc:</span> <span class="pl-s"><span class="pl-pds">'</span>your last name<span class="pl-pds">'</span></span>
<span class="pl-k">end</span>

<span class="pl-c1">Descriptive</span>.filters.each <span class="pl-k">do </span>|<span class="pl-smi">name</span>, <span class="pl-smi">filter</span>|
  puts <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">#{</span><span class="pl-s1">name</span><span class="pl-pse"><span class="pl-s1">}</span></span>: <span class="pl-pse">#{</span><span class="pl-s1">filter.desc</span><span class="pl-pse"><span class="pl-s1">}</span></span><span class="pl-pds">"</span></span>
<span class="pl-k">end</span>
<span class="pl-c"># first_name: your first name</span>
<span class="pl-c"># last_name: your last name</span></pre></div>

<h3>
<a id="errors" class="anchor" href="#errors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Errors</h3>

<p>ActiveInteraction provides detailed errors for easier introspection and testing
of errors. Detailed errors improve on regular errors by adding a symbol that
represents the type of error that has occurred. Let's look at an example where
an item is purchased using a credit card.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">BuyItem<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  object <span class="pl-c1">:credit_card</span>, <span class="pl-c1">:item</span>
  hash <span class="pl-c1">:options</span> <span class="pl-k">do</span>
    boolean <span class="pl-c1">:gift_wrapped</span>
  <span class="pl-k">end</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    order <span class="pl-k">=</span> credit_card.purchase(item)
    notify(credit_card.account)
    order
  <span class="pl-k">end</span>

  <span class="pl-k">private</span> <span class="pl-k">def</span> <span class="pl-en">notify</span>(<span class="pl-smi">account</span>)
    <span class="pl-c"># ...</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>Having missing or invalid inputs causes the interaction to fail and return
errors.</p>

<div class="highlight highlight-source-ruby"><pre>outcome <span class="pl-k">=</span> <span class="pl-c1">BuyItem</span>.run(<span class="pl-c1">item:</span> <span class="pl-s"><span class="pl-pds">'</span>Thing<span class="pl-pds">'</span></span>, <span class="pl-c1">options:</span> { <span class="pl-c1">gift_wrapped:</span> <span class="pl-s"><span class="pl-pds">'</span>yes<span class="pl-pds">'</span></span> })
outcome.errors.messages
<span class="pl-c"># =&gt; {:credit_card=&gt;["is required"], :item=&gt;["is not a valid object"], :options=&gt;["has an invalid nested value (\"gift_wrapped\" =&gt; \"yes\")"]}</span></pre></div>

<p>Determining the type of error based on the string is difficult if not
impossible. Calling <code>#details</code> instead of <code>#messages</code> on <code>errors</code> gives you
the same list of errors with a testable label representing the error.</p>

<div class="highlight highlight-source-ruby"><pre>outcome.errors.details
<span class="pl-c"># =&gt; {:credit_card=&gt;[{:error=&gt;:missing}], :item=&gt;[{:type=&gt;"object", :error=&gt;:invalid_type}], :options=&gt;[{:name=&gt;"\"gift_wrapped\"", :value=&gt;"\"yes\"", :error=&gt;:invalid_nested}]}</span></pre></div>

<p>Detailed errors can also be manually added during the execute call by passing a
symbol to <code>#add</code> instead of a string.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">def</span> <span class="pl-en">execute</span>
  errors.add(<span class="pl-c1">:monster</span>, <span class="pl-c1">:no_passage</span>)
<span class="pl-k">end</span></pre></div>

<p>These types of errors will become standard with Rails 5. ActiveInteraction's
implementation is based off of <a href="https://github.com/cowbell/active_model-errors_details">active_model-errors_details</a>.</p>

<p>ActiveInteraction also supports merging errors. This is useful if you want to
delegate validation to some other object. For example, if you have an
interaction that updates a record, you might want that record to validate
itself. By using the <code>#merge!</code> helper on <code>errors</code>, you can do exactly that.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">UpdateThing<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  object <span class="pl-c1">:thing</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    <span class="pl-k">unless</span> thing.save
      errors.merge!(thing.errors)
    <span class="pl-k">end</span>

    thing
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>When a composed interaction fails, its errors are merged onto the caller. This
generally produces good error messages, but there are a few cases to look out
for.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">Inner<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  boolean <span class="pl-c1">:x</span>, <span class="pl-c1">:y</span>
<span class="pl-k">end</span>

<span class="pl-k">class</span> <span class="pl-en">Outer<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  string <span class="pl-c1">:x</span>
  boolean <span class="pl-c1">:z</span>, <span class="pl-c1">default:</span> <span class="pl-c1">nil</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    compose(<span class="pl-c1">Inner</span>, <span class="pl-c1">x:</span> x, <span class="pl-c1">y:</span> z)
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

outcome <span class="pl-k">=</span> <span class="pl-c1">Outer</span>.run(<span class="pl-c1">x:</span> <span class="pl-s"><span class="pl-pds">'</span>yes<span class="pl-pds">'</span></span>)
outcome.errors.details
<span class="pl-c"># =&gt; { :x    =&gt; [{ :error =&gt; :invalid_type, :type =&gt; "boolean" }],</span>
<span class="pl-c">#      :base =&gt; [{ :error =&gt; "Y is required" }] }</span>
outcome.errors.full_messages.join(<span class="pl-s"><span class="pl-pds">'</span> and <span class="pl-pds">'</span></span>)
<span class="pl-c"># =&gt; "X is not a valid boolean and Y is required"</span></pre></div>

<p>Since both interactions have an input called <code>x</code>, the inner error for that
input is moved to the <code>x</code> error on the outer interaction. This results in a
misleading error that claims the input <code>x</code> is not a valid boolean even though
it's a string on the outer interaction.</p>

<p>Since only the inner interaction has an input called <code>y</code>, the inner error for
that input is moved to the <code>base</code> error on the outer interaction. This results
in a confusing error that claims the input <code>y</code> is required even though it's not
present on the outer interaction.</p>

<h3>
<a id="forms" class="anchor" href="#forms" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Forms</h3>

<p>The outcome returned by <code>.run</code> can be used in forms as though it were an
ActiveModel object. You can also create a form object by calling <code>.new</code> on the
interaction.</p>

<p>Given an application with an <code>Account</code> model we'll create a new <code>Account</code> using
the <code>CreateAccount</code> interaction.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-c"># GET /accounts/new</span>
<span class="pl-k">def</span> <span class="pl-en">new</span>
  <span class="pl-smi">@account</span> <span class="pl-k">=</span> <span class="pl-c1">CreateAccount</span>.<span class="pl-k">new</span>
<span class="pl-k">end</span>

<span class="pl-c"># POST /accounts</span>
<span class="pl-k">def</span> <span class="pl-en">create</span>
  outcome <span class="pl-k">=</span> <span class="pl-c1">CreateAccount</span>.run(params.fetch(<span class="pl-c1">:account</span>, {}))

  <span class="pl-k">if</span> outcome.valid?
    redirect_to(outcome.result)
  <span class="pl-k">else</span>
    <span class="pl-smi">@account</span> <span class="pl-k">=</span> outcome
    render(<span class="pl-c1">:new</span>)
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>The form used to create a new <code>Account</code> has slightly more information on the
<code>form_for</code> call than you might expect.</p>

<div class="highlight highlight-text-html-erb"><pre><span class="pl-pse">&lt;%=</span><span class="pl-s1"> form_for <span class="pl-smi">@account</span>, <span class="pl-c1">as:</span> <span class="pl-c1">:account</span>, <span class="pl-c1">url:</span> accounts_path <span class="pl-k">do </span>|<span class="pl-smi">f</span>| </span><span class="pl-pse"><span class="pl-s1">%</span>&gt;</span>
  <span class="pl-pse">&lt;%=</span><span class="pl-s1"> f.text_field <span class="pl-c1">:first_name</span> </span><span class="pl-pse"><span class="pl-s1">%</span>&gt;</span>
  <span class="pl-pse">&lt;%=</span><span class="pl-s1"> f.text_field <span class="pl-c1">:last_name</span> </span><span class="pl-pse"><span class="pl-s1">%</span>&gt;</span>
  <span class="pl-pse">&lt;%=</span><span class="pl-s1"> f.submit <span class="pl-s"><span class="pl-pds">'</span>Create<span class="pl-pds">'</span></span> </span><span class="pl-pse"><span class="pl-s1">%</span>&gt;</span>
<span class="pl-pse">&lt;%</span><span class="pl-s1"> <span class="pl-k">end</span> </span><span class="pl-pse"><span class="pl-s1">%</span>&gt;</span></pre></div>

<p>This is necessary because we want the form to act like it is creating a new
<code>Account</code>. Defining <code>to_model</code> on the <code>CreateAccount</code> interaction tells the
form to treat our interaction like an <code>Account</code>.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">CreateAccount<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  <span class="pl-c"># ...</span>

  <span class="pl-k">def</span> <span class="pl-en">to_model</span>
    <span class="pl-c1">Account</span>.<span class="pl-k">new</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>Now our <code>form_for</code> call knows how to generate the correct URL and param name
(i.e. <code>params[:account]</code>).</p>

<div class="highlight highlight-text-html-erb"><pre># app/views/accounts/new.html.erb
<span class="pl-pse">&lt;%=</span><span class="pl-s1"> form_for <span class="pl-smi">@account</span> <span class="pl-k">do </span>|<span class="pl-smi">f</span>| </span><span class="pl-pse"><span class="pl-s1">%</span>&gt;</span>
  <span class="pl-c">&lt;%# ... %&gt;</span>
<span class="pl-pse">&lt;%</span><span class="pl-s1"> <span class="pl-k">end</span> </span><span class="pl-pse"><span class="pl-s1">%</span>&gt;</span></pre></div>

<p>If you have an interaction that updates an <code>Account</code>, you can define <code>to_model</code>
to return the object you're updating.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">UpdateAccount<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  <span class="pl-c"># ...</span>

  object <span class="pl-c1">:account</span>

  <span class="pl-k">def</span> <span class="pl-en">to_model</span>
    account
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>ActiveInteraction also supports <a href="https://rubygems.org/gems/formtastic">formtastic</a> and <a href="https://rubygems.org/gems/simple_form">simple_form</a>. The filters
used to define the inputs on your interaction will relay type information to
these gems. As a result, form fields will automatically use the appropriate
input type.</p>

<h3>
<a id="grouped-inputs" class="anchor" href="#grouped-inputs" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Grouped inputs</h3>

<p>It can be convenient to apply the same options to a bunch of inputs. One common
use case is making many inputs optional. Instead of setting <code>default: nil</code> on
each one of them, you can use <a href="http://api.rubyonrails.org/classes/Object.html#method-i-with_options"><code>with_options</code></a> to reduce duplication.</p>

<div class="highlight highlight-source-ruby"><pre>with_options <span class="pl-c1">default:</span> <span class="pl-c1">nil</span> <span class="pl-k">do</span>
  date <span class="pl-c1">:birthday</span>
  string <span class="pl-c1">:name</span>
  boolean <span class="pl-c1">:wants_cake</span>
<span class="pl-k">end</span></pre></div>

<h3>
<a id="optional-inputs" class="anchor" href="#optional-inputs" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Optional inputs</h3>

<p>Optional inputs can be defined by using the <code>:default</code> option as described in
<a href="#filters">the filters section</a>. Within the interaction, provided and default values
are merged to create <code>inputs</code>. There are times where it is useful to know
whether a value was passed to <code>run</code> or the result of a filter default. In
particular, it is useful when <code>nil</code> is an acceptable value. For example, you
may optionally track your users' birthdays. You can use the <code>given?</code> predicate
to see if an input was even passed to <code>run</code>.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">UpdateUser<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  object <span class="pl-c1">:user</span>
  date <span class="pl-c1">:birthday</span>,
    <span class="pl-c1">default:</span> <span class="pl-c1">nil</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    user.birthday <span class="pl-k">=</span> birthday <span class="pl-k">if</span> given?(<span class="pl-c1">:birthday</span>)
    errors.merge!(user.errors) <span class="pl-k">unless</span> user.save
    user
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>Now you have a few options. If you don't want to update their birthday, leave
it out of the hash. If you want to remove their birthday, set <code>birthday: nil</code>.
And if you want to update it, pass in the new value as usual.</p>

<div class="highlight highlight-source-ruby"><pre>user <span class="pl-k">=</span> <span class="pl-c1">User</span>.find(...)

<span class="pl-c"># Don't update their birthday.</span>
<span class="pl-c1">UpdateUser</span>.run!(<span class="pl-c1">user:</span> user)

<span class="pl-c"># Remove their birthday.</span>
<span class="pl-c1">UpdateUser</span>.run!(<span class="pl-c1">user:</span> user, <span class="pl-c1">birthday:</span> <span class="pl-c1">nil</span>)

<span class="pl-c"># Update their birthday.</span>
<span class="pl-c1">UpdateUser</span>.run!(<span class="pl-c1">user:</span> user, <span class="pl-c1">birthday:</span> <span class="pl-c1">Date</span>.<span class="pl-k">new</span>(<span class="pl-c1">2000</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>))</pre></div>

<h3>
<a id="predicates" class="anchor" href="#predicates" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Predicates</h3>

<p>ActiveInteraction creates a predicate method for every input defined by a
filter. So if you have an input called <code>foo</code>, there will be a predicate method
called <code>#foo?</code>. That method will tell you if the input was given (that is, if
it was not <code>nil</code>).</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">SayHello<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  string <span class="pl-c1">:name</span>,
    <span class="pl-c1">default:</span> <span class="pl-c1">nil</span>

  <span class="pl-k">def</span> <span class="pl-en">execute</span>
    <span class="pl-k">if</span> name?
      <span class="pl-s"><span class="pl-pds">"</span>Hello, <span class="pl-pse">#{</span><span class="pl-s1">name</span><span class="pl-pse"><span class="pl-s1">}</span></span>!<span class="pl-pds">"</span></span>
    <span class="pl-k">else</span>
      <span class="pl-s"><span class="pl-pds">"</span>Howdy, stranger!<span class="pl-pds">"</span></span>
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c1">SayHello</span>.run!(<span class="pl-c1">name:</span> <span class="pl-c1">nil</span>)
<span class="pl-c"># =&gt; "Howdy, stranger!"</span>
<span class="pl-c1">SayHello</span>.run!(<span class="pl-c1">name:</span> <span class="pl-s"><span class="pl-pds">'</span>Taylor<span class="pl-pds">'</span></span>)
<span class="pl-c"># =&gt; "Hello, Taylor!"</span></pre></div>

<p>This can be confusing for boolean inputs. If you have some boolean input <code>foo</code>,
then the actual value of that input is available through <code>foo</code>. The associated
predicate method, <code>#foo?</code>, will tell you if that value is not <code>nil</code>. So it will
only be <code>false</code> if the input is optional and happens to be <code>nil</code>.</p>

<p>See <a href="#optional-inputs">the optional inputs section</a> for help on determining if an input was
present in the input hash instead of just <code>nil</code>.</p>

<h3>
<a id="translations" class="anchor" href="#translations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Translations</h3>

<p>ActiveInteraction is i18n aware out of the box! All you have to do is add
translations to your project. In Rails, these typically go into
<code>config/locales</code>. For example, let's say that for some reason you want to print
everything out backwards. Simply add translations for ActiveInteraction to your
<code>hsilgne</code> locale.</p>

<div class="highlight highlight-source-yaml"><pre><span class="pl-c"># config/locales/hsilgne.yml</span>
<span class="pl-ent">hsilgne:</span>
  <span class="pl-ent">active_interaction:</span>
    <span class="pl-ent">types:</span>
      <span class="pl-ent">array:</span> <span class="pl-s">yarra</span>
      <span class="pl-ent">boolean:</span> <span class="pl-s">naeloob</span>
      <span class="pl-ent">date:</span> <span class="pl-s">etad</span>
      <span class="pl-ent">date_time:</span> <span class="pl-s">emit etad</span>
      <span class="pl-ent">decimal:</span> <span class="pl-s">lamiced</span>
      <span class="pl-ent">file:</span> <span class="pl-s">elif</span>
      <span class="pl-ent">float:</span> <span class="pl-s">taolf</span>
      <span class="pl-ent">hash:</span> <span class="pl-s">hsah</span>
      <span class="pl-ent">integer:</span> <span class="pl-s">regetni</span>
      <span class="pl-ent">interface:</span> <span class="pl-s">ecafretni</span>
      <span class="pl-ent">object:</span> <span class="pl-s">tcejbo</span>
      <span class="pl-ent">string:</span> <span class="pl-s">gnirts</span>
      <span class="pl-ent">symbol:</span> <span class="pl-s">lobmys</span>
      <span class="pl-ent">time:</span> <span class="pl-s">emit</span>
    <span class="pl-ent">errors:</span>
      <span class="pl-ent">messages:</span>
        <span class="pl-ent">invalid:</span> <span class="pl-s">dilavni si</span>
        <span class="pl-ent">invalid_nested:</span> <span class="pl-s">(%{value} &lt;= %{name}) eulav detsen dilavni na sah</span>
        <span class="pl-ent">invalid_type:</span> <span class="pl-s"><span class="pl-pds">'</span>%{type} dilav a ton si<span class="pl-pds">'</span></span>
        <span class="pl-ent">missing:</span> <span class="pl-s">deriuqer si</span></pre></div>

<p>Then set your locale and run interactions like normal.</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">I18nInteraction<span class="pl-e"> &lt; ActiveInteraction::Base</span></span>
  string <span class="pl-c1">:name</span>
<span class="pl-k">end</span>

<span class="pl-c1">I18nInteraction</span>.run(<span class="pl-c1">name:</span> <span class="pl-c1">false</span>).errors.messages[<span class="pl-c1">:name</span>]
<span class="pl-c"># =&gt; ["is not a valid string"]</span>

<span class="pl-c1">I18n</span>.locale <span class="pl-k">=</span> <span class="pl-c1">:hsilgne</span>
<span class="pl-c1">I18nInteraction</span>.run(<span class="pl-c1">name:</span> <span class="pl-c1">false</span>).errors.messages[<span class="pl-c1">:name</span>]
<span class="pl-c"># =&gt; ["gnirts dilav a ton si"]</span></pre></div>

<h2>
<a id="credits" class="anchor" href="#credits" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Credits</h2>

<p>ActiveInteraction is brought to you by <a href="https://github.com/AaronLasseigne">Aaron Lasseigne</a> and
<a href="https://github.com/tfausak">Taylor Fausak</a> from <a href="https://github.com/orgsync">OrgSync</a>. We were inspired by the fantastic work done
by <a href="https://github.com/cypriss">Jonathan Novak</a> on <a href="https://github.com/cypriss/mutations">Mutations</a>.</p>

<p>If you want to contribute to ActiveInteraction, please read
<a href="CONTRIBUTING.md">our contribution guidelines</a>. A <a href="https://github.com/orgsync/active_interaction/graphs/contributors">complete list of contributors</a> is
available on GitHub.</p>

<p>ActiveInteraction is licensed under <a href="LICENSE.md">the MIT License</a>.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/orgsync/active_interaction">ActiveInteraction</a> is maintained by <a href="https://github.com/orgsync">orgsync</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
